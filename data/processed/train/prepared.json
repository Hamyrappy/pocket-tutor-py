{"13": {"student_solution": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and color in cite_project:\n    print(True)\nelse:\n    print(False)", "task": "Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:\n\nДаны два списка logo_project и cite_project с кодами используемых цветов (строки).\nВ переменную color считывается код цвета (строка). Этот код уже написан.\nПрограмма должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. \nВ остальных случаях программа печатает False. ", "correct_example": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse:\n    print(False)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n#a7f0ca\nОжидаемый ответ:\nTrue\nОтвет решения:\nFalse\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "14": {"student_solution": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif not(color in logo_project) and not(color in cite_project):\n    print(True)\nelse:\n    print(False)", "task": "Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:\n\nДаны два списка logo_project и cite_project с кодами используемых цветов (строки).\nВ переменную color считывается код цвета (строка). Этот код уже написан.\nПрограмма должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. \nВ остальных случаях программа печатает False. ", "correct_example": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse:\n    print(False)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n#a7f0ca\nОжидаемый ответ:\nTrue\nОтвет решения:\nFalse\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "15": {"student_solution": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif not(color in logo_project) and color in cite_project:\n    print(True)\nelse:\n    print(False)", "task": "Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:\n\nДаны два списка logo_project и cite_project с кодами используемых цветов (строки).\nВ переменную color считывается код цвета (строка). Этот код уже написан.\nПрограмма должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. \nВ остальных случаях программа печатает False. ", "correct_example": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse:\n    print(False)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n#a7f0ca\nОжидаемый ответ:\nTrue\nОтвет решения:\nFalse\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "16": {"student_solution": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(False)\nelse:\n    print(True)", "task": "Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:\n\nДаны два списка logo_project и cite_project с кодами используемых цветов (строки).\nВ переменную color считывается код цвета (строка). Этот код уже написан.\nПрограмма должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. \nВ остальных случаях программа печатает False. ", "correct_example": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse:\n    print(False)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n#a7f0ca\nОжидаемый ответ:\nTrue\nОтвет решения:\nFalse\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "17": {"student_solution": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse\n    print(False)", "task": "Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:\n\nДаны два списка logo_project и cite_project с кодами используемых цветов (строки).\nВ переменную color считывается код цвета (строка). Этот код уже написан.\nПрограмма должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. \nВ остальных случаях программа печатает False. ", "correct_example": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse:\n    print(False)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n#a7f0ca\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\0\\codefile.py\", line 9\n    else\n        ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "18": {"student_solution": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolour = input()\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse:\n    print(False)", "task": "Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:\n\nДаны два списка logo_project и cite_project с кодами используемых цветов (строки).\nВ переменную color считывается код цвета (строка). Этот код уже написан.\nПрограмма должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. \nВ остальных случаях программа печатает False. ", "correct_example": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse:\n    print(False)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n#a7f0ca\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\0\\codefile.py\", line 7, in <module>\n    if color in logo_project and not(color in cite_project):\nNameError: name 'color' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "19": {"student_solution": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse:\nprint(False)", "task": "Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:\n\nДаны два списка logo_project и cite_project с кодами используемых цветов (строки).\nВ переменную color считывается код цвета (строка). Этот код уже написан.\nПрограмма должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. \nВ остальных случаях программа печатает False. ", "correct_example": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse:\n    print(False)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n#a7f0ca\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\0\\codefile.py\", line 10\n    print(False)\n    ^\nIndentationError: expected an indented block\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "20": {"student_solution": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse:\n    print(False", "task": "Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:\n\nДаны два списка logo_project и cite_project с кодами используемых цветов (строки).\nВ переменную color считывается код цвета (строка). Этот код уже написан.\nПрограмма должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. \nВ остальных случаях программа печатает False. ", "correct_example": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse:\n    print(False)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n#a7f0ca\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\0\\codefile.py\", line 11\n    \n    ^\nSyntaxError: unexpected EOF while parsing\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "21": {"student_solution": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not in cite_project:\n    print(True)\nelse:\n    print(False)", "task": "Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:\n\nДаны два списка logo_project и cite_project с кодами используемых цветов (строки).\nВ переменную color считывается код цвета (строка). Этот код уже написан.\nПрограмма должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. \nВ остальных случаях программа печатает False. ", "correct_example": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse:\n    print(False)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n#a7f0ca\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\0\\codefile.py\", line 7\n    if color in logo_project and not in cite_project:\n                                     ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "22": {"student_solution": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = int(input())\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse:\n    print(False)", "task": "Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:\n\nДаны два списка logo_project и cite_project с кодами используемых цветов (строки).\nВ переменную color считывается код цвета (строка). Этот код уже написан.\nПрограмма должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. \nВ остальных случаях программа печатает False. ", "correct_example": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse:\n    print(False)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n#a7f0ca\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\0\\codefile.py\", line 5, in <module>\n    color = int(input())\nValueError: invalid literal for int() with base 10: '#a7f0ca'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "23": {"student_solution": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse color in cite_project:\n    print(False)", "task": "Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:\n\nДаны два списка logo_project и cite_project с кодами используемых цветов (строки).\nВ переменную color считывается код цвета (строка). Этот код уже написан.\nПрограмма должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. \nВ остальных случаях программа печатает False. ", "correct_example": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse:\n    print(False)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n#a7f0ca\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\0\\codefile.py\", line 9\n    else color in cite_project:\n         ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "24": {"student_solution": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(true)\nelse:\n    print(false)", "task": "Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:\n\nДаны два списка logo_project и cite_project с кодами используемых цветов (строки).\nВ переменную color считывается код цвета (строка). Этот код уже написан.\nПрограмма должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. \nВ остальных случаях программа печатает False. ", "correct_example": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse:\n    print(False)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n#a7f0ca\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\0\\codefile.py\", line 8, in <module>\n    print(true)\nNameError: name 'true' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "25": {"student_solution": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logoproject and not(color in citeproject):\n    print(True)\nelse:\n    print(False)", "task": "Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:\n\nДаны два списка logo_project и cite_project с кодами используемых цветов (строки).\nВ переменную color считывается код цвета (строка). Этот код уже написан.\nПрограмма должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. \nВ остальных случаях программа печатает False. ", "correct_example": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse:\n    print(False)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n#a7f0ca\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\0\\codefile.py\", line 7, in <module>\n    if color in logoproject and not(color in citeproject):\nNameError: name 'logoproject' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "26": {"student_solution": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif not(color in cite_project):\n    print(True)\nelse:\n    print(False)", "task": "Реализуйте программу, которая проверит, что цвет используется только в проекте по созданию логотипа, но не в проекте по созданию дизайна сайта:\n\nДаны два списка logo_project и cite_project с кодами используемых цветов (строки).\nВ переменную color считывается код цвета (строка). Этот код уже написан.\nПрограмма должна проверять, что код цвета color есть только в списке logo_project, и если да, то печатать True. \nВ остальных случаях программа печатает False. ", "correct_example": "logo_project = ['#a7a8f0', '#a7f0ca', '#b3b4e4', '#e4b3cd', '#e4e3b3', '#c0ced7']\ncite_project = ['#e4e3b3', '#a7a8f0', '#ccb1e6', '#b4f99e', '#f9b59e', '#c0ced7']\n\ncolor = input()\n\nif color in logo_project and not(color in cite_project):\n    print(True)\nelse:\n    print(False)", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "27": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'END':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\1\\codefile.py\", line 5, in <module>\n    info = input()\nEOFError: EOF when reading a line\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "28": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n    break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\1\\codefile.py\", line 7\n    break\n    ^\nIndentationError: expected an indented block\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "29": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if result == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\1\\codefile.py\", line 5, in <module>\n    info = input()\nEOFError: EOF when reading a line\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "30": {"student_solution": "result = 0\n\nwhile True\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\1\\codefile.py\", line 4\n    while True\n              ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "31": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info = 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\1\\codefile.py\", line 6\n    if info = 'СТОП':\n            ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "32": {"student_solution": "while True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\1\\codefile.py\", line 8, in <module>\n    result += 1\nNameError: name 'result' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "33": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \nif '_' not in info and info.isupper():\n    result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП\nОжидаемый ответ:\n0\nОтвет решения:\n1\n\n", "error_on_open": true, "error_on_closed": false, "syntax_error": false}, "34": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if _ not in info and info.isupper():\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\1\\codefile.py\", line 9, in <module>\n    if _ not in info and info.isupper():\nNameError: name '_' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "35": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.isupper():\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nПРОЕКТ_1\nработа_ФИН\nФинальная_работа\nСТОП\nОжидаемый ответ:\n0\nОтвет решения:\n1\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "36": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info:\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП\nОжидаемый ответ:\n1\nОтвет решения:\n2\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "37": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.upper():\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП\nОжидаемый ответ:\n1\nОтвет решения:\n2\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "38": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        info += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\1\\codefile.py\", line 10, in <module>\n    info += 1\nTypeError: can only concatenate str (not \"int\") to str\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "39": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result + 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП\nОжидаемый ответ:\n1\nОтвет решения:\n0\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "40": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \n    print(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП\nОжидаемый ответ:\n1\nОтвет решения:\n1\n1\n1\n1\n1\n1\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "41": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(info)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП\nОжидаемый ответ:\n1\nОтвет решения:\nСТОП\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "42": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info:\n        result += 1\n    elif  info.isupper():\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из заглавных букв и в которых нет знака подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.isupper():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект 3\nПроект_4\nинтерьер_\n_диз_ИНТ\nСТОП\nОжидаемый ответ:\n1\nОтвет решения:\n3\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "43": {"student_solution": "logo = input()\n\nres = {}\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "task": "Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: \n\nВ переменную logo считывается текст лендинга. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака \"#\" и которые не состоят только из цифр (не включая знак \"#\"). Гарантируется, что хэштеги отделены от другого текста пробелом. \nВ конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.\nЕсли знаков хэштегов в тексте нет, то программа ничего не печатает.", "correct_example": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nВыучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\2\\codefile.py\", line 7, in <module>\n    res.append(info)\nAttributeError: 'dict' object has no attribute 'append'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "44": {"student_solution": "logo = input()\n\nres = []\nfor i in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "task": "Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: \n\nВ переменную logo считывается текст лендинга. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака \"#\" и которые не состоят только из цифр (не включая знак \"#\"). Гарантируется, что хэштеги отделены от другого текста пробелом. \nВ конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.\nЕсли знаков хэштегов в тексте нет, то программа ничего не печатает.", "correct_example": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nВыучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\2\\codefile.py\", line 6, in <module>\n    if info.startswith('#') and info[1:].isdigit() == False:      \nNameError: name 'info' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "45": {"student_solution": "logo = input()\n\nres = []\nfor info in logo.split()\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "task": "Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: \n\nВ переменную logo считывается текст лендинга. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака \"#\" и которые не состоят только из цифр (не включая знак \"#\"). Гарантируется, что хэштеги отделены от другого текста пробелом. \nВ конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.\nЕсли знаков хэштегов в тексте нет, то программа ничего не печатает.", "correct_example": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nВыучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\2\\codefile.py\", line 5\n    for info in logo.split()\n                            ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "46": {"student_solution": "logo = input()\n\nres = []\nfor info in logo:\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "task": "Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: \n\nВ переменную logo считывается текст лендинга. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака \"#\" и которые не состоят только из цифр (не включая знак \"#\"). Гарантируется, что хэштеги отделены от другого текста пробелом. \nВ конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.\nЕсли знаков хэштегов в тексте нет, то программа ничего не печатает.", "correct_example": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nВыучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.\nОжидаемый ответ:\n#the_best_app\nОтвет решения:\n#, #\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "47": {"student_solution": "logo = input()\n\nres = []\nfor info in logo.split:\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "task": "Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: \n\nВ переменную logo считывается текст лендинга. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака \"#\" и которые не состоят только из цифр (не включая знак \"#\"). Гарантируется, что хэштеги отделены от другого текста пробелом. \nВ конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.\nЕсли знаков хэштегов в тексте нет, то программа ничего не печатает.", "correct_example": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nВыучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\2\\codefile.py\", line 5, in <module>\n    for info in logo.split:\nTypeError: 'builtin_function_or_method' object is not iterable\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "48": {"student_solution": "logo = input()\n\nres = []\nfor info in logo.split():\nif info.startswith('#') and info[1:].isdigit() == False:      \n    res.append(info)\n        \nprint(*res, sep=', ')", "task": "Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: \n\nВ переменную logo считывается текст лендинга. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака \"#\" и которые не состоят только из цифр (не включая знак \"#\"). Гарантируется, что хэштеги отделены от другого текста пробелом. \nВ конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.\nЕсли знаков хэштегов в тексте нет, то программа ничего не печатает.", "correct_example": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nВыучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\2\\codefile.py\", line 6\n    if info.startswith('#') and info[1:].isdigit() == False:      \n    ^\nIndentationError: expected an indented block\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "49": {"student_solution": "logo = input()\n\nres = []\nfor info in logo.split():\n    if '#' in info and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "task": "Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: \n\nВ переменную logo считывается текст лендинга. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака \"#\" и которые не состоят только из цифр (не включая знак \"#\"). Гарантируется, что хэштеги отделены от другого текста пробелом. \nВ конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.\nЕсли знаков хэштегов в тексте нет, то программа ничего не печатает.", "correct_example": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nЯ никогда не был #счастье1 #любовь123 #123_123 qwe#qwe\nОжидаемый ответ:\n#счастье1, #любовь123, #123_123\nОтвет решения:\n#счастье1, #любовь123, #123_123, qwe#qwe\n\n", "error_on_open": false, "error_on_closed": true, "syntax_error": false}, "50": {"student_solution": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#'):      \n        res.append(info)\n        \nprint(*res, sep=', ')", "task": "Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: \n\nВ переменную logo считывается текст лендинга. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака \"#\" и которые не состоят только из цифр (не включая знак \"#\"). Гарантируется, что хэштеги отделены от другого текста пробелом. \nВ конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.\nЕсли знаков хэштегов в тексте нет, то программа ничего не печатает.", "correct_example": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nВыучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.\nОжидаемый ответ:\n#the_best_app\nОтвет решения:\n#the_best_app, #20\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "51": {"student_solution": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#'):      \n        res.append(info)\n    if info[1:].isdigit() == False:\n        res.append(info)\n        \nprint(*res, sep=', ')", "task": "Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: \n\nВ переменную logo считывается текст лендинга. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака \"#\" и которые не состоят только из цифр (не включая знак \"#\"). Гарантируется, что хэштеги отделены от другого текста пробелом. \nВ конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.\nЕсли знаков хэштегов в тексте нет, то программа ничего не печатает.", "correct_example": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nВыучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.\nОжидаемый ответ:\n#the_best_app\nОтвет решения:\nВыучите, китайский, язык, без, усилий, выполняя, задания, в, приложении, (, #the_best_app, #the_best_app, ), за, #20, дней.\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "52": {"student_solution": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info.isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "task": "Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: \n\nВ переменную logo считывается текст лендинга. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака \"#\" и которые не состоят только из цифр (не включая знак \"#\"). Гарантируется, что хэштеги отделены от другого текста пробелом. \nВ конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.\nЕсли знаков хэштегов в тексте нет, то программа ничего не печатает.", "correct_example": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nВыучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.\nОжидаемый ответ:\n#the_best_app\nОтвет решения:\n#the_best_app, #20\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "53": {"student_solution": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.add(info)\n        \nprint(*res, sep=', ')", "task": "Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: \n\nВ переменную logo считывается текст лендинга. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака \"#\" и которые не состоят только из цифр (не включая знак \"#\"). Гарантируется, что хэштеги отделены от другого текста пробелом. \nВ конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.\nЕсли знаков хэштегов в тексте нет, то программа ничего не печатает.", "correct_example": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nВыучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\2\\codefile.py\", line 7, in <module>\n    res.add(info)\nAttributeError: 'list' object has no attribute 'add'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "54": {"student_solution": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res)", "task": "Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: \n\nВ переменную logo считывается текст лендинга. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака \"#\" и которые не состоят только из цифр (не включая знак \"#\"). Гарантируется, что хэштеги отделены от другого текста пробелом. \nВ конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.\nЕсли знаков хэштегов в тексте нет, то программа ничего не печатает.", "correct_example": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nВаш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 %\nОжидаемый ответ:\n#question, #answer\nОтвет решения:\n#question #answer\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "55": {"student_solution": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(res)", "task": "Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: \n\nВ переменную logo считывается текст лендинга. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака \"#\" и которые не состоят только из цифр (не включая знак \"#\"). Гарантируется, что хэштеги отделены от другого текста пробелом. \nВ конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.\nЕсли знаков хэштегов в тексте нет, то программа ничего не печатает.", "correct_example": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nВыучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.\nОжидаемый ответ:\n#the_best_app\nОтвет решения:\n['#the_best_app']\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "56": {"student_solution": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=',')", "task": "Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: \n\nВ переменную logo считывается текст лендинга. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака \"#\" и которые не состоят только из цифр (не включая знак \"#\"). Гарантируется, что хэштеги отделены от другого текста пробелом. \nВ конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.\nЕсли знаков хэштегов в тексте нет, то программа ничего не печатает.", "correct_example": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nВаш вопрос ( #question ) - наш ответ ( #answer ) ! Мы всегда с Вами yf #100 %\nОжидаемый ответ:\n#question, #answer\nОтвет решения:\n#question,#answer\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "57": {"student_solution": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(logo)\n        \nprint(*res, sep=', ')", "task": "Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: \n\nВ переменную logo считывается текст лендинга. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака \"#\" и которые не состоят только из цифр (не включая знак \"#\"). Гарантируется, что хэштеги отделены от другого текста пробелом. \nВ конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.\nЕсли знаков хэштегов в тексте нет, то программа ничего не печатает.", "correct_example": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nВыучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.\nОжидаемый ответ:\n#the_best_app\nОтвет решения:\nВыучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "58": {"student_solution": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(logo)", "task": "Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: \n\nВ переменную logo считывается текст лендинга. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака \"#\" и которые не состоят только из цифр (не включая знак \"#\"). Гарантируется, что хэштеги отделены от другого текста пробелом. \nВ конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.\nЕсли знаков хэштегов в тексте нет, то программа ничего не печатает.", "correct_example": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nВыучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.\nОжидаемый ответ:\n#the_best_app\nОтвет решения:\nВыучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "59": {"student_solution": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \n    print(res)", "task": "Реализуйте программу, которая напечатает хэштеги из фраз для лендинга сайта: \n\nВ переменную logo считывается текст лендинга. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте хэштеги.  Хэштегами можно считать все элементы, которые начинаются со знака \"#\" и которые не состоят только из цифр (не включая знак \"#\"). Гарантируется, что хэштеги отделены от другого текста пробелом. \nВ конце программа печатает все хэштеги через запятую с пробелом. Хэштеги выводятся в том же порядке, в котором они идут в тексте.\nЕсли знаков хэштегов в тексте нет, то программа ничего не печатает.", "correct_example": "logo = input()\n\nres = []\nfor info in logo.split():\n    if info.startswith('#') and info[1:].isdigit() == False:      \n        res.append(info)\n        \nprint(*res, sep=', ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nВыучите китайский язык без усилий выполняя задания в приложении ( #the_best_app ) за #20 дней.\nОжидаемый ответ:\n#the_best_app\nОтвет решения:\n[]\n[]\n[]\n[]\n[]\n[]\n[]\n[]\n[]\n[]\n['#the_best_app']\n['#the_best_app']\n['#the_best_app']\n['#the_best_app']\n['#the_best_app']\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "90": {"student_solution": "def designer (designers, sizes, towns)\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "task": "Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первом списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым легким проектом. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 2\n    def designer (designers, sizes, towns)\n                                          ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "91": {"student_solution": "def designer():\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "task": "Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первом списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым легким проектом. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\nTypeError: designer() takes 0 positional arguments but 3 were given\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "92": {"student_solution": "def designer():\n    designers = input()\n    sizes = input( list(map(int, sizes)))\n    towns = input()\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "task": "Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первом списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым легким проектом. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 14, in <module>\n    print(designer (designers, sizes, towns))\nTypeError: designer() takes 0 positional arguments but 3 were given\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "93": {"student_solution": "def designer (designers, sizes, towns):\n    sizes =int(sizes)\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "task": "Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первом списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым легким проектом. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 3, in designer\n    sizes =int(sizes)\nTypeError: int() argument must be a string, a bytes-like object or a number, not 'list'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "94": {"student_solution": "def designer (designers, sizes, towns):\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "task": "Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первом списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым легким проектом. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "95": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(towns):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "task": "Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первом списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым легким проектом. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 6, in designer\n    for i in range(towns):\nTypeError: 'list' object cannot be interpreted as an integer\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "96": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != Москва and towns[i] != Санкт-Петербург:\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "task": "Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первом списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым легким проектом. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 7, in designer\n    if towns[i] != Москва and towns[i] != Санкт-Петербург:\nNameError: name 'Москва' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "97": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n       if towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "task": "Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первом списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым легким проектом. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 10\n    if towns[i] != \"Санкт-Петербург\":\n                                                   ^\nIndentationError: unindent does not match any outer indentation level\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "98": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.add(designers[i])\n            lst_of_siz.add(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "task": "Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первом списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым легким проектом. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 8, in designer\n    lst_of_des.add(designers[i])\nAttributeError: 'list' object has no attribute 'add'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "99": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    print(lst_of_des[lst_of_siz.index(min(lst_of_siz))])", "task": "Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первом списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым легким проектом. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nОжидаемый ответ:\nГуськов\nОтвет решения:\nГуськов\nNone\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "100": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[min(lst_of_siz)]", "task": "Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первом списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым легким проектом. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 11, in designer\n    return lst_of_des[min(lst_of_siz)]\nIndexError: list index out of range\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "101": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(min(lst_of_des))]", "task": "Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первом списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым легким проектом. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 11, in designer\n    return lst_of_des[lst_of_siz.index(min(lst_of_des))]\nValueError: 'Гуськов' is not in list\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "102": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]", "task": "Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первом списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым легким проектом. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nОжидаемый ответ:\nГуськов\nОтвет решения:\nПеньков\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "103": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \nreturn lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "task": "Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первом списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым легким проектом. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 11\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]\n    ^\nSyntaxError: 'return' outside function\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "104": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return ans = lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "task": "Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первом списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым легким проектом. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 11\n    return ans = lst_of_des[lst_of_siz.index(min(lst_of_siz))]\n               ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "105": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(int(sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "task": "Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первом списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым легким проектом. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 3, in designer\n    sizes = list(int(sizes))\nTypeError: int() argument must be a string, a bytes-like object or a number, not 'list'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "106": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\" and towns[i] == \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "task": "Напишите функцию, определяющую дизайнера, который работает над самым легким проектом.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первом списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым легким считается проект, в котором площадь помещения минимальна и город, в котором находится помещение, над которым работает дизайнер, не Москва или Санкт-Петербург. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым легким проектом. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\" and towns[i] != \"Санкт-Петербург\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\3\\codefile.py\", line 11, in designer\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]\nValueError: min() arg is an empty sequence\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "107": {"student_solution": "year = input()\n\nwith open('projects_file.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "task": "Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..\n\nПрограмма должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка \"2019,200 тыс. руб.,10 недель\" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.\nГарантируется, что стоимость реализованного проекта всегда записана в формате \"<целое число> тыс. руб.\".\nГарантируется, что срок реализации проекта всегда записан в формате \"<целое число> недель\".\nРазделителями данных в файле служат запятые.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — год.\nПрограмма должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "108": {"student_solution": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "task": "Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..\n\nПрограмма должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка \"2019,200 тыс. руб.,10 недель\" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.\nГарантируется, что стоимость реализованного проекта всегда записана в формате \"<целое число> тыс. руб.\".\nГарантируется, что срок реализации проекта всегда записан в формате \"<целое число> недель\".\nРазделителями данных в файле служат запятые.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — год.\nПрограмма должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "109": {"student_solution": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "task": "Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..\n\nПрограмма должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка \"2019,200 тыс. руб.,10 недель\" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.\nГарантируется, что стоимость реализованного проекта всегда записана в формате \"<целое число> тыс. руб.\".\nГарантируется, что срок реализации проекта всегда записан в формате \"<целое число> недель\".\nРазделителями данных в файле служат запятые.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — год.\nПрограмма должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "110": {"student_solution": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "task": "Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..\n\nПрограмма должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка \"2019,200 тыс. руб.,10 недель\" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.\nГарантируется, что стоимость реализованного проекта всегда записана в формате \"<целое число> тыс. руб.\".\nГарантируется, что срок реализации проекта всегда записан в формате \"<целое число> недель\".\nРазделителями данных в файле служат запятые.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — год.\nПрограмма должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "111": {"student_solution": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(', ')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "task": "Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..\n\nПрограмма должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка \"2019,200 тыс. руб.,10 недель\" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.\nГарантируется, что стоимость реализованного проекта всегда записана в формате \"<целое число> тыс. руб.\".\nГарантируется, что срок реализации проекта всегда записан в формате \"<целое число> недель\".\nРазделителями данных в файле служат запятые.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — год.\nПрограмма должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "112": {"student_solution": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] < year and int(info[-2].split()[0]) <= 500:\n            print(line)", "task": "Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..\n\nПрограмма должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка \"2019,200 тыс. руб.,10 недель\" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.\nГарантируется, что стоимость реализованного проекта всегда записана в формате \"<целое число> тыс. руб.\".\nГарантируется, что срок реализации проекта всегда записан в формате \"<целое число> недель\".\nРазделителями данных в файле служат запятые.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — год.\nПрограмма должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "113": {"student_solution": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) < 500:\n            print(line)", "task": "Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..\n\nПрограмма должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка \"2019,200 тыс. руб.,10 недель\" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.\nГарантируется, что стоимость реализованного проекта всегда записана в формате \"<целое число> тыс. руб.\".\nГарантируется, что срок реализации проекта всегда записан в формате \"<целое число> недель\".\nРазделителями данных в файле служат запятые.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — год.\nПрограмма должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "114": {"student_solution": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year or int(info[-2].split()[0]) <= 500:\n            print(line)", "task": "Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..\n\nПрограмма должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка \"2019,200 тыс. руб.,10 недель\" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.\nГарантируется, что стоимость реализованного проекта всегда записана в формате \"<целое число> тыс. руб.\".\nГарантируется, что срок реализации проекта всегда записан в формате \"<целое число> недель\".\nРазделителями данных в файле служат запятые.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — год.\nПрограмма должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "115": {"student_solution": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and info[-2].split()[0] <= 500:\n            print(line)", "task": "Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..\n\nПрограмма должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка \"2019,200 тыс. руб.,10 недель\" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.\nГарантируется, что стоимость реализованного проекта всегда записана в формате \"<целое число> тыс. руб.\".\nГарантируется, что срок реализации проекта всегда записан в формате \"<целое число> недель\".\nРазделителями данных в файле служат запятые.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — год.\nПрограмма должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "116": {"student_solution": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year:\n            print(line)\n        if int(info[-2].split()[0]) <= 500:\n            print(line)", "task": "Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..\n\nПрограмма должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка \"2019,200 тыс. руб.,10 недель\" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.\nГарантируется, что стоимость реализованного проекта всегда записана в формате \"<целое число> тыс. руб.\".\nГарантируется, что срок реализации проекта всегда записан в формате \"<целое число> недель\".\nРазделителями данных в файле служат запятые.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — год.\nПрограмма должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "117": {"student_solution": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n        print(line)", "task": "Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..\n\nПрограмма должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка \"2019,200 тыс. руб.,10 недель\" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.\nГарантируется, что стоимость реализованного проекта всегда записана в формате \"<целое число> тыс. руб.\".\nГарантируется, что срок реализации проекта всегда записан в формате \"<целое число> недель\".\nРазделителями данных в файле служат запятые.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — год.\nПрограмма должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "118": {"student_solution": "year = input()\nans = []\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            ans.append(line)\n\nprint(*ans)", "task": "Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..\n\nПрограмма должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка \"2019,200 тыс. руб.,10 недель\" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.\nГарантируется, что стоимость реализованного проекта всегда записана в формате \"<целое число> тыс. руб.\".\nГарантируется, что срок реализации проекта всегда записан в формате \"<целое число> недель\".\nРазделителями данных в файле служат запятые.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — год.\nПрограмма должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "119": {"student_solution": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[2].split()[0]) <= 500:\n            print(line)", "task": "Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..\n\nПрограмма должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка \"2019,200 тыс. руб.,10 недель\" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.\nГарантируется, что стоимость реализованного проекта всегда записана в формате \"<целое число> тыс. руб.\".\nГарантируется, что срок реализации проекта всегда записан в формате \"<целое число> недель\".\nРазделителями данных в файле служат запятые.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — год.\nПрограмма должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "120": {"student_solution": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[1] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "task": "Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..\n\nПрограмма должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка \"2019,200 тыс. руб.,10 недель\" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.\nГарантируется, что стоимость реализованного проекта всегда записана в формате \"<целое число> тыс. руб.\".\nГарантируется, что срок реализации проекта всегда записан в формате \"<целое число> недель\".\nРазделителями данных в файле служат запятые.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — год.\nПрограмма должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "121": {"student_solution": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(year)", "task": "Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..\n\nПрограмма должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка \"2019,200 тыс. руб.,10 недель\" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.\nГарантируется, что стоимость реализованного проекта всегда записана в формате \"<целое число> тыс. руб.\".\nГарантируется, что срок реализации проекта всегда записан в формате \"<целое число> недель\".\nРазделителями данных в файле служат запятые.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — год.\nПрограмма должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "122": {"student_solution": "year = input()\n\nopen('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "task": "Ксения анализирует реализованные дизайн-проекты, которые собраны в файле формата csv. Напишите программу, которая выводит все строки, соответствующие реализованным в определенный период проектам, стоимость которых была не более 500 тыс. руб..\n\nПрограмма должна открывать структурированный текстовый файл projects_file.csv, в кодировке utf-8, где на каждой строке записана следующая информация о дизайн-проекте: год, стоимость проекта, количество недель, за сколько был реализован проект. Например, строка \"2019,200 тыс. руб.,10 недель\" означает, что в 2019 году проект стоимостью 200 тыс. руб. был реализован за 10 недель.\nГарантируется, что стоимость реализованного проекта всегда записана в формате \"<целое число> тыс. руб.\".\nГарантируется, что срок реализации проекта всегда записан в формате \"<целое число> недель\".\nРазделителями данных в файле служат запятые.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — год.\nПрограмма должна выводить строки из оригинального файла, которые соответствуют проектам, реализованным не позднее, чем в указанном году, со стоимостью не более 500. тыс. руб. (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл projects_file.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл projects_file.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "year = input()\n\nwith open('projects_file.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        info = line.split(',')\n        if info[0] <= year and int(info[-2].split()[0]) <= 500:\n            print(line)", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "220": {"student_solution": "result = 0\ninfo = input()\n\nwhile info != 'СТОП':\n    info = input()\n        \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n_дизайнер_\n_ПРОГРАМИСТ_\n_пробный\nПРОЕКТ!\n_____п\nСТОП\nОжидаемый ответ:\n3\nОтвет решения:\n2\n\n", "error_on_open": false, "error_on_closed": true, "syntax_error": false}, "221": {"student_solution": "result = 0\n\nwhile True\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\5\\codefile.py\", line 4\n    while True\n              ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "222": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'END':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\5\\codefile.py\", line 5, in <module>\n    info = input()\nEOFError: EOF when reading a line\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "223": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info = 'СТОП':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\5\\codefile.py\", line 6\n    if info = 'СТОП':\n            ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "224": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if _ in info and info.islower():\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\5\\codefile.py\", line 9, in <module>\n    if _ in info and info.islower():\nNameError: name '_' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "225": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' not in info and info.islower():\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП\nОжидаемый ответ:\n2\nОтвет решения:\n0\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "226": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info or info.islower():\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП\nОжидаемый ответ:\n2\nОтвет решения:\n4\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "227": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.lower():\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП\nОжидаемый ответ:\n2\nОтвет решения:\n4\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "228": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \nif '_' in info and info.islower():\n    result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП\nОжидаемый ответ:\n2\nОтвет решения:\n0\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "229": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info:\n         result += 1\n    if info.islower():\n         result += 1\n\nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП\nОжидаемый ответ:\n2\nОтвет решения:\n6\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "230": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(info)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП\nОжидаемый ответ:\n2\nОтвет решения:\nСТОП\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "231": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \n    print(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП\nОжидаемый ответ:\n2\nОтвет решения:\n0\n0\n1\n1\n2\n2\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "232": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if info.islower():\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nПРОЕКТ_1\nПРОЕКТ_2\nПРОЕКТ_3\nПРОЕКТ!4\nпроект 1\nСТОП\nОжидаемый ответ:\n0\nОтвет решения:\n1\n\n", "error_on_open": false, "error_on_closed": true, "syntax_error": false}, "233": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info:\n        result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nПРОЕКТ 1\nПРОЕКТ_2\nпроект_3\nПроект 4\nинтерьер_\n_диз_ИНТ\nСТОП\nОжидаемый ответ:\n2\nОтвет решения:\n4\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "234": {"student_solution": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if info.islower():\n        for i in info:\n            if i == '_':\n                result += 1\n        \nprint(result)", "task": "Реализуйте программу, которая определит количество корректных названий проектов для конкурса дизайнеров интерьера:\n\nВ цикле while считываются названия проектов до тех пор, пока не введена строка \"СТОП\".\nГарантируется, что названия проектов не повторяются. \nГарантируется, что до строки \"СТОП\" будет введена как минимум одна строка.\nНапечатайте количество проектов, которые состоят только из букв нижнего регистра и в которых есть знак подчеркивания.", "correct_example": "result = 0\n\nwhile True:\n    info = input()\n    if info == 'СТОП':\n        break\n    \n    if '_' in info and info.islower():\n        result += 1\n        \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n123_ПРОГА_П\n123_прога_п\n123ПРОГАП?\n123 ПРОГА п\nСТОП\nОжидаемый ответ:\n1\nОтвет решения:\n2\n\n", "error_on_open": false, "error_on_closed": true, "syntax_error": false}, "281": {"student_solution": "def designer (designers, sizes, towns)\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ", "task": "Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первой списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 2\n    def designer (designers, sizes, towns)\n                                          ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "282": {"student_solution": "def designer ():\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ", "task": "Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первой списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\nTypeError: designer() takes 0 positional arguments but 3 were given\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "283": {"student_solution": "def designer (designers, ammount, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ", "task": "Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первой списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 3, in designer\n    sizes = list(map(int, sizes))\nUnboundLocalError: local variable 'sizes' referenced before assignment\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "284": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.add(designers[i])\n            lst_of_siz.add(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ", "task": "Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первой списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 8, in designer\n    lst_of_des.add(designers[i])\nAttributeError: 'list' object has no attribute 'add'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "285": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    print(lst_of_des[lst_of_siz.index(max(lst_of_siz))])", "task": "Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первой списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nОжидаемый ответ:\nКруглов\nОтвет решения:\nМарков\nNone\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "286": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \nreturn lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ", "task": "Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первой списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 11\n    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  \n    ^\nSyntaxError: 'return' outside function\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "287": {"student_solution": "def designer (designers, sizes, towns):\n    sizes =int(sizes)\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ", "task": "Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первой списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 3, in designer\n    sizes =int(sizes)\nTypeError: int() argument must be a string, a bytes-like object or a number, not 'list'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "288": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(towns):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ", "task": "Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первой списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 6, in designer\n    for i in range(towns):\nTypeError: 'list' object cannot be interpreted as an integer\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "289": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in len(towns):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ", "task": "Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первой списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 6, in designer\n    for i in len(towns):\nTypeError: 'int' object is not iterable\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "290": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] = \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ", "task": "Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первой списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 7\n    if towns[i] = \"Москва\":\n                ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "291": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == Москва:\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(max(lst_of_siz))]  ", "task": "Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первой списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 7, in designer\n    if towns[i] == Москва:\nNameError: name 'Москва' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "292": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[max(lst_of_siz)]  ", "task": "Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первой списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 11, in designer\n    return lst_of_des[max(lst_of_siz)]  \nIndexError: list index out of range\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "293": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ", "task": "Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первой списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "294": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(min(lst_of_des))]  ", "task": "Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первой списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 11, in designer\n    return lst_of_des[lst_of_siz.index(min(lst_of_des))]  \nValueError: 'Круглов' is not in list\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "295": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] != \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ", "task": "Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первой списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nОжидаемый ответ:\nКруглов\nОтвет решения:\nГуськов\n\nНа одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Степанов'], ['100'], ['Москва']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 11, in designer\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  \nValueError: min() arg is an empty sequence\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "296": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_ofdes[lst_of_siz.index(min(lst_of_siz))]  ", "task": "Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первой списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 11, in designer\n    return lst_ofdes[lst_of_siz.index(min(lst_of_siz))]  \nNameError: name 'lst_ofdes' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "297": {"student_solution": "def designer (designers, sizes, towns):\n    sizes = map(int, sizes)\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n    \n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]  ", "task": "Напишите функцию, определяющую дизайнера, который работает над самым сложным проектом в городе Москва.\n\nОпределите функцию designer, которая принимает на вход три списка:\nв первой списке перечислены фамилии дизайнеров;\nво втором списке перечислены размеры помещений (в кв. м.) (строки), для которых эти дизайнеры создают проекты интерьера соответственно.\nв третьем списке перечислены города, в которых располагаются помещения.\nГарантируется, что фамилии дизайнеров не повторяются. При этом размеры помещений могут повторяться.\nСамым сложным считается проект, в котором площадь помещения максимальна. Гарантируется, что такой проект только один.\nФункция должна возвращать фамилию дизайнера, который работает над самым сложным проектом в городе Москва. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def designer (designers, sizes, towns):\n    sizes = list(map(int, sizes))\n    lst_of_des = []\n    lst_of_siz = []\n    for i in range(len(towns)):\n        if towns[i] == \"Москва\":\n            lst_of_des.append(designers[i])\n            lst_of_siz.append(sizes[i])\n\n    return lst_of_des[lst_of_siz.index(min(lst_of_siz))]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n['Круглов', 'Квадратов', 'Иванов', 'Марков', 'Пеньков', 'Гуськов'], ['100', '60', '67', '120', '90', '32'], ['Москва', 'Санкт-Петербург', 'Пермь', 'Москва', 'Сочи', 'Иваново']\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 12, in <module>\n    print(designer (designers, sizes, towns))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\6\\codefile.py\", line 9, in designer\n    lst_of_siz.append(sizes[i])\nTypeError: 'map' object is not subscriptable\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "334": {"student_solution": "data = input().split(';')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "task": "Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. \n\nФОРМАТ ВВОДА\nНа первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. \nНа второй строке вводится название вуза, в котором обучается Андрей. \nФОРМАТ ВЫВОДА\nНазвания студий дизайна, куда Андрея не могут взять на работу.\nНазвания должны выводиться через прямой слэш и пробел (\"/ \") в обратном алфавитном порядке.\nЕсли таких студий нет, программа ничего не выводит.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.\nСчитайте в переменную название вуза.\nСоздайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.\nОбратитесь к каждому элементу из списка, созданного в п.1:\nразбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;\nесли вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.\nОтсортируйте получившийся список в обратном алфавитном порядке. \nНапечатайте элементы списка через прямой слэш и пробел.", "correct_example": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nGreenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ\nОжидаемый ответ:\nA29\nОтвет решения:\n A29\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "335": {"student_solution": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(';')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "task": "Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. \n\nФОРМАТ ВВОДА\nНа первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. \nНа второй строке вводится название вуза, в котором обучается Андрей. \nФОРМАТ ВЫВОДА\nНазвания студий дизайна, куда Андрея не могут взять на работу.\nНазвания должны выводиться через прямой слэш и пробел (\"/ \") в обратном алфавитном порядке.\nЕсли таких студий нет, программа ничего не выводит.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.\nСчитайте в переменную название вуза.\nСоздайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.\nОбратитесь к каждому элементу из списка, созданного в п.1:\nразбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;\nесли вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.\nОтсортируйте получившийся список в обратном алфавитном порядке. \nНапечатайте элементы списка через прямой слэш и пробел.", "correct_example": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nGreenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\7\\codefile.py\", line 7, in <module>\n    st, univ = studio.split(';')\nValueError: not enough values to unpack (expected 2, got 1)\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "336": {"student_solution": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split('; ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "task": "Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. \n\nФОРМАТ ВВОДА\nНа первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. \nНа второй строке вводится название вуза, в котором обучается Андрей. \nФОРМАТ ВЫВОДА\nНазвания студий дизайна, куда Андрея не могут взять на работу.\nНазвания должны выводиться через прямой слэш и пробел (\"/ \") в обратном алфавитном порядке.\nЕсли таких студий нет, программа ничего не выводит.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.\nСчитайте в переменную название вуза.\nСоздайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.\nОбратитесь к каждому элементу из списка, созданного в п.1:\nразбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;\nесли вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.\nОтсортируйте получившийся список в обратном алфавитном порядке. \nНапечатайте элементы списка через прямой слэш и пробел.", "correct_example": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nGreenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ\nОжидаемый ответ:\nA29\nОтвет решения:\nVDT/ Greenfield/ DA Bureau/ A29\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "337": {"student_solution": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor i in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "task": "Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. \n\nФОРМАТ ВВОДА\nНа первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. \nНа второй строке вводится название вуза, в котором обучается Андрей. \nФОРМАТ ВЫВОДА\nНазвания студий дизайна, куда Андрея не могут взять на работу.\nНазвания должны выводиться через прямой слэш и пробел (\"/ \") в обратном алфавитном порядке.\nЕсли таких студий нет, программа ничего не выводит.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.\nСчитайте в переменную название вуза.\nСоздайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.\nОбратитесь к каждому элементу из списка, созданного в п.1:\nразбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;\nесли вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.\nОтсортируйте получившийся список в обратном алфавитном порядке. \nНапечатайте элементы списка через прямой слэш и пробел.", "correct_example": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nGreenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\7\\codefile.py\", line 7, in <module>\n    st, univ = studio.split(': ')\nNameError: name 'studio' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "338": {"student_solution": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "task": "Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. \n\nФОРМАТ ВВОДА\nНа первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. \nНа второй строке вводится название вуза, в котором обучается Андрей. \nФОРМАТ ВЫВОДА\nНазвания студий дизайна, куда Андрея не могут взять на работу.\nНазвания должны выводиться через прямой слэш и пробел (\"/ \") в обратном алфавитном порядке.\nЕсли таких студий нет, программа ничего не выводит.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.\nСчитайте в переменную название вуза.\nСоздайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.\nОбратитесь к каждому элементу из списка, созданного в п.1:\nразбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;\nесли вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.\nОтсортируйте получившийся список в обратном алфавитном порядке. \nНапечатайте элементы списка через прямой слэш и пробел.", "correct_example": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nGreenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ\nОжидаемый ответ:\nA29\nОтвет решения:\nVDT/ Greenfield/ DA Bureau\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "339": {"student_solution": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.add(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "task": "Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. \n\nФОРМАТ ВВОДА\nНа первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. \nНа второй строке вводится название вуза, в котором обучается Андрей. \nФОРМАТ ВЫВОДА\nНазвания студий дизайна, куда Андрея не могут взять на работу.\nНазвания должны выводиться через прямой слэш и пробел (\"/ \") в обратном алфавитном порядке.\nЕсли таких студий нет, программа ничего не выводит.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.\nСчитайте в переменную название вуза.\nСоздайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.\nОбратитесь к каждому элементу из списка, созданного в п.1:\nразбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;\nесли вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.\nОтсортируйте получившийся список в обратном алфавитном порядке. \nНапечатайте элементы списка через прямой слэш и пробел.", "correct_example": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nGreenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\7\\codefile.py\", line 10, in <module>\n    result.add(st)\nAttributeError: 'list' object has no attribute 'add'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "340": {"student_solution": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(result)", "task": "Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. \n\nФОРМАТ ВВОДА\nНа первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. \nНа второй строке вводится название вуза, в котором обучается Андрей. \nФОРМАТ ВЫВОДА\nНазвания студий дизайна, куда Андрея не могут взять на работу.\nНазвания должны выводиться через прямой слэш и пробел (\"/ \") в обратном алфавитном порядке.\nЕсли таких студий нет, программа ничего не выводит.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.\nСчитайте в переменную название вуза.\nСоздайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.\nОбратитесь к каждому элементу из списка, созданного в п.1:\nразбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;\nесли вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.\nОтсортируйте получившийся список в обратном алфавитном порядке. \nНапечатайте элементы списка через прямой слэш и пробел.", "correct_example": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nGreenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ\nОжидаемый ответ:\nA29\nОтвет решения:\n['A29']\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "341": {"student_solution": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result)", "task": "Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. \n\nФОРМАТ ВВОДА\nНа первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. \nНа второй строке вводится название вуза, в котором обучается Андрей. \nФОРМАТ ВЫВОДА\nНазвания студий дизайна, куда Андрея не могут взять на работу.\nНазвания должны выводиться через прямой слэш и пробел (\"/ \") в обратном алфавитном порядке.\nЕсли таких студий нет, программа ничего не выводит.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.\nСчитайте в переменную название вуза.\nСоздайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.\nОбратитесь к каждому элементу из списка, созданного в п.1:\nразбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;\nесли вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.\nОтсортируйте получившийся список в обратном алфавитном порядке. \nНапечатайте элементы списка через прямой слэш и пробел.", "correct_example": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nGreenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\7\\codefile.py\", line 13\n    \n    ^\nSyntaxError: unexpected EOF while parsing\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "342": {"student_solution": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result), sep = '/ ')", "task": "Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. \n\nФОРМАТ ВВОДА\nНа первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. \nНа второй строке вводится название вуза, в котором обучается Андрей. \nФОРМАТ ВЫВОДА\nНазвания студий дизайна, куда Андрея не могут взять на работу.\nНазвания должны выводиться через прямой слэш и пробел (\"/ \") в обратном алфавитном порядке.\nЕсли таких студий нет, программа ничего не выводит.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.\nСчитайте в переменную название вуза.\nСоздайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.\nОбратитесь к каждому элементу из списка, созданного в п.1:\nразбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;\nесли вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.\nОтсортируйте получившийся список в обратном алфавитном порядке. \nНапечатайте элементы списка через прямой слэш и пробел.", "correct_example": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nGreenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ\nВШЭ\nОжидаемый ответ:\nSuite n.7/ Greenfield/ Da-sein\nОтвет решения:\nDa-sein/ Greenfield/ Suite n.7\n\n", "error_on_open": false, "error_on_closed": true, "syntax_error": false}, "343": {"student_solution": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True))", "task": "Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. \n\nФОРМАТ ВВОДА\nНа первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. \nНа второй строке вводится название вуза, в котором обучается Андрей. \nФОРМАТ ВЫВОДА\nНазвания студий дизайна, куда Андрея не могут взять на работу.\nНазвания должны выводиться через прямой слэш и пробел (\"/ \") в обратном алфавитном порядке.\nЕсли таких студий нет, программа ничего не выводит.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.\nСчитайте в переменную название вуза.\nСоздайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.\nОбратитесь к каждому элементу из списка, созданного в п.1:\nразбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;\nесли вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.\nОтсортируйте получившийся список в обратном алфавитном порядке. \nНапечатайте элементы списка через прямой слэш и пробел.", "correct_example": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nGreenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ\nВШЭ\nОжидаемый ответ:\nSuite n.7/ Greenfield/ Da-sein\nОтвет решения:\nSuite n.7 Greenfield Da-sein\n\n", "error_on_open": false, "error_on_closed": true, "syntax_error": false}, "344": {"student_solution": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\n    print(*sorted(result, reverse = True), sep = '/ ')", "task": "Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. \n\nФОРМАТ ВВОДА\nНа первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. \nНа второй строке вводится название вуза, в котором обучается Андрей. \nФОРМАТ ВЫВОДА\nНазвания студий дизайна, куда Андрея не могут взять на работу.\nНазвания должны выводиться через прямой слэш и пробел (\"/ \") в обратном алфавитном порядке.\nЕсли таких студий нет, программа ничего не выводит.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.\nСчитайте в переменную название вуза.\nСоздайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.\nОбратитесь к каждому элементу из списка, созданного в п.1:\nразбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;\nесли вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.\nОтсортируйте получившийся список в обратном алфавитном порядке. \nНапечатайте элементы списка через прямой слэш и пробел.", "correct_example": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nGreenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ\nОжидаемый ответ:\nA29\nОтвет решения:\n\n\nA29\nA29\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "345": {"student_solution": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "task": "Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. \n\nФОРМАТ ВВОДА\nНа первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. \nНа второй строке вводится название вуза, в котором обучается Андрей. \nФОРМАТ ВЫВОДА\nНазвания студий дизайна, куда Андрея не могут взять на работу.\nНазвания должны выводиться через прямой слэш и пробел (\"/ \") в обратном алфавитном порядке.\nЕсли таких студий нет, программа ничего не выводит.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.\nСчитайте в переменную название вуза.\nСоздайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.\nОбратитесь к каждому элементу из списка, созданного в п.1:\nразбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;\nесли вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.\nОтсортируйте получившийся список в обратном алфавитном порядке. \nНапечатайте элементы списка через прямой слэш и пробел.", "correct_example": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nGreenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\7\\codefile.py\", line 6\n    for studio in data\n                      ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "346": {"student_solution": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(univ)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "task": "Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. \n\nФОРМАТ ВВОДА\nНа первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. \nНа второй строке вводится название вуза, в котором обучается Андрей. \nФОРМАТ ВЫВОДА\nНазвания студий дизайна, куда Андрея не могут взять на работу.\nНазвания должны выводиться через прямой слэш и пробел (\"/ \") в обратном алфавитном порядке.\nЕсли таких студий нет, программа ничего не выводит.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.\nСчитайте в переменную название вуза.\nСоздайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.\nОбратитесь к каждому элементу из списка, созданного в п.1:\nразбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;\nесли вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.\nОтсортируйте получившийся список в обратном алфавитном порядке. \nНапечатайте элементы списка через прямой слэш и пробел.", "correct_example": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nGreenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ\nОжидаемый ответ:\nA29\nОтвет решения:\n['МИФИ', 'МФТИ', 'МГСУ', 'РАНХиГС']\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "347": {"student_solution": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(studio)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "task": "Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. \n\nФОРМАТ ВВОДА\nНа первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. \nНа второй строке вводится название вуза, в котором обучается Андрей. \nФОРМАТ ВЫВОДА\nНазвания студий дизайна, куда Андрея не могут взять на работу.\nНазвания должны выводиться через прямой слэш и пробел (\"/ \") в обратном алфавитном порядке.\nЕсли таких студий нет, программа ничего не выводит.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.\nСчитайте в переменную название вуза.\nСоздайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.\nОбратитесь к каждому элементу из списка, созданного в п.1:\nразбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;\nесли вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.\nОтсортируйте получившийся список в обратном алфавитном порядке. \nНапечатайте элементы списка через прямой слэш и пробел.", "correct_example": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nGreenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ\nОжидаемый ответ:\nA29\nОтвет решения:\nA29: МИФИ, МФТИ, МГСУ, РАНХиГС\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "348": {"student_solution": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = ' / ')", "task": "Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. \n\nФОРМАТ ВВОДА\nНа первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. \nНа второй строке вводится название вуза, в котором обучается Андрей. \nФОРМАТ ВЫВОДА\nНазвания студий дизайна, куда Андрея не могут взять на работу.\nНазвания должны выводиться через прямой слэш и пробел (\"/ \") в обратном алфавитном порядке.\nЕсли таких студий нет, программа ничего не выводит.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.\nСчитайте в переменную название вуза.\nСоздайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.\nОбратитесь к каждому элементу из списка, созданного в п.1:\nразбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;\nесли вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.\nОтсортируйте получившийся список в обратном алфавитном порядке. \nНапечатайте элементы списка через прямой слэш и пробел.", "correct_example": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nGreenfield: МГСУ; Da-sein: МГСУ; Suite n.7: МГСУ\nВШЭ\nОжидаемый ответ:\nSuite n.7/ Greenfield/ Da-sein\nОтвет решения:\nSuite n.7 / Greenfield / Da-sein\n\n", "error_on_open": false, "error_on_closed": true, "syntax_error": false}, "349": {"student_solution": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\nif university not in univ:\n    result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "task": "Андрей хочет пойти работать в одну из студий дизайна интерьеров и смотрит, выпускников каких вузов они хотели бы у себя видеть. Напишите программу, которая поможет Андрею определить студии, куда его не могут взять на работу. \n\nФОРМАТ ВВОДА\nНа первой строке через точку с запятой и пробел вводится информация о компании и вузах '<название студии дизайна>: <названия вузов через запятую и пробел>'. Гарантируется, что строка содержит информацию минимум об одной компании. \nНа второй строке вводится название вуза, в котором обучается Андрей. \nФОРМАТ ВЫВОДА\nНазвания студий дизайна, куда Андрея не могут взять на работу.\nНазвания должны выводиться через прямой слэш и пробел (\"/ \") в обратном алфавитном порядке.\nЕсли таких студий нет, программа ничего не выводит.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте в переменную строку со студиями и вузами, сразу разделите по разделителю и получите список.\nСчитайте в переменную название вуза.\nСоздайте пустой список, в который будете добавлять название студии, если она готова пригласить Андрея на стажировку.\nОбратитесь к каждому элементу из списка, созданного в п.1:\nразбейте его (строку) по разделителю и сохраните название студии в одну переменную, а названия вузов — в другую переменную;\nесли вуза Андрея (переменная из п.2) нет в названиях вузов, то добавьте название студии в список из п.3.\nОтсортируйте получившийся список в обратном алфавитном порядке. \nНапечатайте элементы списка через прямой слэш и пробел.", "correct_example": "data = input().split('; ')\nuniversity = input()\n\nresult = []\nfor studio in data:\n    st, univ = studio.split(': ')\n    univ = univ.split(', ')\n    if university not in univ:\n        result.append(st)\n\nprint(*sorted(result, reverse = True), sep = '/ ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nGreenfield: МГУ, ВШЭ, МГСУ, СПбГУ; VDT: ВШЭ, РГГУ, Бауманка; A29: МИФИ, МФТИ, МГСУ, РАНХиГС; DA Bureau: РАНХиГС, ВШЭ, МГУ\nВШЭ\nОжидаемый ответ:\nA29\nОтвет решения:\n\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "368": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nopen('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "369": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "370": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "371": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "372": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n                \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "373": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "374": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for word in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "375": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "376": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[1].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "377": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith(#):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "378": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isalnum():\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "379": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "380": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data:\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "381": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if k >= 2:\n        res.append(v)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "382": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "383": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.add(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "384": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*res)", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "385": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res))", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "386": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True))", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "387": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res), sep='; ')", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "388": {"student_solution": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \n    res = []\n\n    for k, v in data.items():\n        if v >= 2:\n            res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "task": "Роман изучает отчет по объекту, где упоминаются различные цвета, которые использовались в проекте. Помогите определить цвета, которые использовались не менее двух раз.\n\nФОРМАТ ВВОДА\nТекстовый файл report.txt, в котором записан отчет по объекту. Гарантируется, что в тексте только названия цветов начинаются с хэштега (\"#\"). \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного цвета.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания цветов, которые использовались в проекте не менее двух раз. \nНазвания должны быть записаны в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл report.txt  Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать цвета и то, сколько раз их использовали в проекте.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первый его элемент — хэштег, тогда это цвет и нужно проверить:\nесли этого цвета еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой цвет уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех цветов, значение которых в словаре больше 1.\nОбратитесь к парам ключ-значение в словаре: если значение больше или равно  2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('report.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip('\\n')\n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].startswith('#'):\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse = True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "414": {"student_solution": "N = input()\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "task": "Реализуйте программу, определяющую слова, которые нужно переводить:\n\nВ переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.\nВ цикле while считывается N слов. \nГарантируется, что будет введена как минимум одна строка.\nНапечатайте количество слов, в которых буква \"а\" вне зависимости от регистра встречается не менее двух раз.", "correct_example": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\9\\codefile.py\", line 14, in <module>\n    N -= 1\nTypeError: unsupported operand type(s) for -=: 'str' and 'int'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "415": {"student_solution": "N = int(input())\n\n# ваш код ниже\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "task": "Реализуйте программу, определяющую слова, которые нужно переводить:\n\nВ переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.\nВ цикле while считывается N слов. \nГарантируется, что будет введена как минимум одна строка.\nНапечатайте количество слов, в которых буква \"а\" вне зависимости от регистра встречается не менее двух раз.", "correct_example": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\9\\codefile.py\", line 10, in <module>\n    result += 1\nNameError: name 'result' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "416": {"student_solution": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != '0':\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "task": "Реализуйте программу, определяющую слова, которые нужно переводить:\n\nВ переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.\nВ цикле while считывается N слов. \nГарантируется, что будет введена как минимум одна строка.\nНапечатайте количество слов, в которых буква \"а\" вне зависимости от регистра встречается не менее двух раз.", "correct_example": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\9\\codefile.py\", line 9, in <module>\n    info = input()\nEOFError: EOF when reading a line\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "417": {"student_solution": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  inf.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "task": "Реализуйте программу, определяющую слова, которые нужно переводить:\n\nВ переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.\nВ цикле while считывается N слов. \nГарантируется, что будет введена как минимум одна строка.\nНапечатайте количество слов, в которых буква \"а\" вне зависимости от регистра встречается не менее двух раз.", "correct_example": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\9\\codefile.py\", line 11, in <module>\n    if  inf.lower().count('а') >= 2:\nNameError: name 'inf' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "418": {"student_solution": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.islower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "task": "Реализуйте программу, определяющую слова, которые нужно переводить:\n\nВ переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.\nВ цикле while считывается N слов. \nГарантируется, что будет введена как минимум одна строка.\nНапечатайте количество слов, в которых буква \"а\" вне зависимости от регистра встречается не менее двух раз.", "correct_example": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\9\\codefile.py\", line 11, in <module>\n    if  info.islower().count('а') >= 2:\nAttributeError: 'bool' object has no attribute 'count'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "419": {"student_solution": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "task": "Реализуйте программу, определяющую слова, которые нужно переводить:\n\nВ переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.\nВ цикле while считывается N слов. \nГарантируется, что будет введена как минимум одна строка.\nНапечатайте количество слов, в которых буква \"а\" вне зависимости от регистра встречается не менее двух раз.", "correct_example": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский\nОжидаемый ответ:\n4\nОтвет решения:\n1\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "420": {"student_solution": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') > 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "task": "Реализуйте программу, определяющую слова, которые нужно переводить:\n\nВ переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.\nВ цикле while считывается N слов. \nГарантируется, что будет введена как минимум одна строка.\nНапечатайте количество слов, в которых буква \"а\" вне зависимости от регистра встречается не менее двух раз.", "correct_example": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский\nОжидаемый ответ:\n4\nОтвет решения:\n1\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "421": {"student_solution": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') <= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "task": "Реализуйте программу, определяющую слова, которые нужно переводить:\n\nВ переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.\nВ цикле while считывается N слов. \nГарантируется, что будет введена как минимум одна строка.\nНапечатайте количество слов, в которых буква \"а\" вне зависимости от регистра встречается не менее двух раз.", "correct_example": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский\nОжидаемый ответ:\n4\nОтвет решения:\n7\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "422": {"student_solution": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \nprint(result)", "task": "Реализуйте программу, определяющую слова, которые нужно переводить:\n\nВ переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.\nВ цикле while считывается N слов. \nГарантируется, что будет введена как минимум одна строка.\nНапечатайте количество слов, в которых буква \"а\" вне зависимости от регистра встречается не менее двух раз.", "correct_example": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\9\\codefile.py\", line 9, in <module>\n    info = input()\nEOFError: EOF when reading a line\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "423": {"student_solution": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N += 1\n    \nprint(result)", "task": "Реализуйте программу, определяющую слова, которые нужно переводить:\n\nВ переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.\nВ цикле while считывается N слов. \nГарантируется, что будет введена как минимум одна строка.\nНапечатайте количество слов, в которых буква \"а\" вне зависимости от регистра встречается не менее двух раз.", "correct_example": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\9\\codefile.py\", line 9, in <module>\n    info = input()\nEOFError: EOF when reading a line\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "424": {"student_solution": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(info)", "task": "Реализуйте программу, определяющую слова, которые нужно переводить:\n\nВ переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.\nВ цикле while считывается N слов. \nГарантируется, что будет введена как минимум одна строка.\nНапечатайте количество слов, в которых буква \"а\" вне зависимости от регистра встречается не менее двух раз.", "correct_example": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский\nОжидаемый ответ:\n4\nОтвет решения:\nанглийский\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "425": {"student_solution": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \nN -= 1\n    \nprint(result)", "task": "Реализуйте программу, определяющую слова, которые нужно переводить:\n\nВ переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.\nВ цикле while считывается N слов. \nГарантируется, что будет введена как минимум одна строка.\nНапечатайте количество слов, в которых буква \"а\" вне зависимости от регистра встречается не менее двух раз.", "correct_example": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\9\\codefile.py\", line 9, in <module>\n    info = input()\nEOFError: EOF when reading a line\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "426": {"student_solution": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \n    print(result)", "task": "Реализуйте программу, определяющую слова, которые нужно переводить:\n\nВ переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.\nВ цикле while считывается N слов. \nГарантируется, что будет введена как минимум одна строка.\nНапечатайте количество слов, в которых буква \"а\" вне зависимости от регистра встречается не менее двух раз.", "correct_example": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский\nОжидаемый ответ:\n4\nОтвет решения:\n1\n1\n1\n2\n3\n3\n4\n4\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "427": {"student_solution": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "task": "Реализуйте программу, определяющую слова, которые нужно переводить:\n\nВ переменную N считывается целое число — количество записей, которые будут введены. Этот код уже написан.\nВ цикле while считывается N слов. \nГарантируется, что будет введена как минимум одна строка.\nНапечатайте количество слов, в которых буква \"а\" вне зависимости от регистра встречается не менее двух раз.", "correct_example": "N = int(input())\n\n# ваш код ниже\n\nresult = 0\n\nwhile N != 0:\n    info = input()\n    \n    if  info.lower().count('а') >= 2:\n        result += 1\n    \n    N -= 1\n    \nprint(result)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n8\nаркА\nриторика\nкультурА\nамфора\nантитезА\nАнтипод\nАтакА\nанглийский\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\9\\codefile.py\", line 11\n    if  info.lower().count('а') >= 2\n                                     ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "428": {"student_solution": "sentence = input()\n\nres = 0\nfor info in sentence:\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "task": "Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: \n\nВ переменную sentence считывается текст. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание \"аз\" или которые заканчиваются на буквосочетание \"ук\". \nГарантируется, что тюркизмы не повторяются.\nВ конце программа печатает количество всех тюркизмов, встречающихся в тексте. \nЕсли названий тюркизмов в тексте нет, программа печатает строку \"Тюркизмов в тексте нет\".", "correct_example": "sentence = input()\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nОткрыв сундук , исследователи увидели сюртук , который сиял как алмаз\nОжидаемый ответ:\n3\nОтвет решения:\nТюркизмов в тексте нет\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "429": {"student_solution": "sentence = input()\n\nres = 0\nfor info in sentence.split():\n    if not(info.isnumeric()) and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "task": "Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: \n\nВ переменную sentence считывается текст. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание \"аз\" или которые заканчиваются на буквосочетание \"ук\". \nГарантируется, что тюркизмы не повторяются.\nВ конце программа печатает количество всех тюркизмов, встречающихся в тексте. \nЕсли названий тюркизмов в тексте нет, программа печатает строку \"Тюркизмов в тексте нет\".", "correct_example": "sentence = input()\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nукрытие укор раз1бор луковица азы! зазор123\nОжидаемый ответ:\nТюркизмов в тексте нет\nОтвет решения:\n3\n\n", "error_on_open": false, "error_on_closed": true, "syntax_error": false}, "430": {"student_solution": "sentence = input()\n\nres = 0\nfor info in sentence.split():\n    if info.isalpha and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "task": "Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: \n\nВ переменную sentence считывается текст. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание \"аз\" или которые заканчиваются на буквосочетание \"ук\". \nГарантируется, что тюркизмы не повторяются.\nВ конце программа печатает количество всех тюркизмов, встречающихся в тексте. \nЕсли названий тюркизмов в тексте нет, программа печатает строку \"Тюркизмов в тексте нет\".", "correct_example": "sentence = input()\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nукрытие укор раз1бор луковица азы! зазор123\nОжидаемый ответ:\nТюркизмов в тексте нет\nОтвет решения:\n3\n\n", "error_on_open": false, "error_on_closed": true, "syntax_error": false}, "431": {"student_solution": "sentence = input()\n\nres = 0\nfor info in sentence.split():\n    if info.isalpha() or (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "task": "Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: \n\nВ переменную sentence считывается текст. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание \"аз\" или которые заканчиваются на буквосочетание \"ук\". \nГарантируется, что тюркизмы не повторяются.\nВ конце программа печатает количество всех тюркизмов, встречающихся в тексте. \nЕсли названий тюркизмов в тексте нет, программа печатает строку \"Тюркизмов в тексте нет\".", "correct_example": "sentence = input()\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nОткрыв сундук , исследователи увидели сюртук , который сиял как алмаз\nОжидаемый ответ:\n3\nОтвет решения:\n9\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "432": {"student_solution": "sentence = input()\n\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') and 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "task": "Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: \n\nВ переменную sentence считывается текст. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание \"аз\" или которые заканчиваются на буквосочетание \"ук\". \nГарантируется, что тюркизмы не повторяются.\nВ конце программа печатает количество всех тюркизмов, встречающихся в тексте. \nЕсли названий тюркизмов в тексте нет, программа печатает строку \"Тюркизмов в тексте нет\".", "correct_example": "sentence = input()\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nОткрыв сундук , исследователи увидели сюртук , который сиял как алмаз\nОжидаемый ответ:\n3\nОтвет решения:\nТюркизмов в тексте нет\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "433": {"student_solution": "sentence = input()\n\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nprint(res)", "task": "Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: \n\nВ переменную sentence считывается текст. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание \"аз\" или которые заканчиваются на буквосочетание \"ук\". \nГарантируется, что тюркизмы не повторяются.\nВ конце программа печатает количество всех тюркизмов, встречающихся в тексте. \nЕсли названий тюркизмов в тексте нет, программа печатает строку \"Тюркизмов в тексте нет\".", "correct_example": "sentence = input()\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nПереводчик переводит текст\nОжидаемый ответ:\nТюркизмов в тексте нет\nОтвет решения:\n0\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "434": {"student_solution": "sentence = input()\n\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n    else:\n        print('Тюркизмов в тексте нет')\nprint(res)", "task": "Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: \n\nВ переменную sentence считывается текст. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание \"аз\" или которые заканчиваются на буквосочетание \"ук\". \nГарантируется, что тюркизмы не повторяются.\nВ конце программа печатает количество всех тюркизмов, встречающихся в тексте. \nЕсли названий тюркизмов в тексте нет, программа печатает строку \"Тюркизмов в тексте нет\".", "correct_example": "sentence = input()\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nОткрыв сундук , исследователи увидели сюртук , который сиял как алмаз\nОжидаемый ответ:\n3\nОтвет решения:\nТюркизмов в тексте нет\nТюркизмов в тексте нет\nТюркизмов в тексте нет\nТюркизмов в тексте нет\nТюркизмов в тексте нет\nТюркизмов в тексте нет\nТюркизмов в тексте нет\nТюркизмов в тексте нет\n3\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "435": {"student_solution": "sentence = input()\n\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res = 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "task": "Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: \n\nВ переменную sentence считывается текст. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание \"аз\" или которые заканчиваются на буквосочетание \"ук\". \nГарантируется, что тюркизмы не повторяются.\nВ конце программа печатает количество всех тюркизмов, встречающихся в тексте. \nЕсли названий тюркизмов в тексте нет, программа печатает строку \"Тюркизмов в тексте нет\".", "correct_example": "sentence = input()\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nОткрыв сундук , исследователи увидели сюртук , который сиял как алмаз\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\10\\codefile.py\", line 9\n    if res = 0:\n           ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "436": {"student_solution": "sentence = input()\n\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info)  \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "task": "Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: \n\nВ переменную sentence считывается текст. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание \"аз\" или которые заканчиваются на буквосочетание \"ук\". \nГарантируется, что тюркизмы не повторяются.\nВ конце программа печатает количество всех тюркизмов, встречающихся в тексте. \nЕсли названий тюркизмов в тексте нет, программа печатает строку \"Тюркизмов в тексте нет\".", "correct_example": "sentence = input()\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nОткрыв сундук , исследователи увидели сюртук , который сиял как алмаз\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\10\\codefile.py\", line 6\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info)  \n                                                                     ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "437": {"student_solution": "sentence = input()\n\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \n    if res == 0:\n        res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "task": "Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: \n\nВ переменную sentence считывается текст. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание \"аз\" или которые заканчиваются на буквосочетание \"ук\". \nГарантируется, что тюркизмы не повторяются.\nВ конце программа печатает количество всех тюркизмов, встречающихся в тексте. \nЕсли названий тюркизмов в тексте нет, программа печатает строку \"Тюркизмов в тексте нет\".", "correct_example": "sentence = input()\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nОткрыв сундук , исследователи увидели сюртук , который сиял как алмаз\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\10\\codefile.py\", line 7, in <module>\n    res += 1\nTypeError: can only concatenate str (not \"int\") to str\n\n", "error_on_open": true, "error_on_closed": false, "syntax_error": false}, "438": {"student_solution": "sentence = input()\n\nres = 0\nfor i in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "task": "Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: \n\nВ переменную sentence считывается текст. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание \"аз\" или которые заканчиваются на буквосочетание \"ук\". \nГарантируется, что тюркизмы не повторяются.\nВ конце программа печатает количество всех тюркизмов, встречающихся в тексте. \nЕсли названий тюркизмов в тексте нет, программа печатает строку \"Тюркизмов в тексте нет\".", "correct_example": "sentence = input()\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nОткрыв сундук , исследователи увидели сюртук , который сиял как алмаз\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\10\\codefile.py\", line 6, in <module>\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \nNameError: name 'info' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "439": {"student_solution": "sentence = input()\n\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(sentence)", "task": "Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: \n\nВ переменную sentence считывается текст. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание \"аз\" или которые заканчиваются на буквосочетание \"ук\". \nГарантируется, что тюркизмы не повторяются.\nВ конце программа печатает количество всех тюркизмов, встречающихся в тексте. \nЕсли названий тюркизмов в тексте нет, программа печатает строку \"Тюркизмов в тексте нет\".", "correct_example": "sentence = input()\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nОткрыв сундук , исследователи увидели сюртук , который сиял как алмаз\nОжидаемый ответ:\n3\nОтвет решения:\nОткрыв сундук , исследователи увидели сюртук , который сиял как алмаз\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "440": {"student_solution": "sentence = input()\n\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\n    print(res)", "task": "Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: \n\nВ переменную sentence считывается текст. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание \"аз\" или которые заканчиваются на буквосочетание \"ук\". \nГарантируется, что тюркизмы не повторяются.\nВ конце программа печатает количество всех тюркизмов, встречающихся в тексте. \nЕсли названий тюркизмов в тексте нет, программа печатает строку \"Тюркизмов в тексте нет\".", "correct_example": "sentence = input()\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nОткрыв сундук , исследователи увидели сюртук , который сиял как алмаз\nОжидаемый ответ:\n3\nОтвет решения:\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "441": {"student_solution": "sentence = input()\n\nres = 0\nfor info in sentence.split():\n    if info.isalpha():      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "task": "Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: \n\nВ переменную sentence считывается текст. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание \"аз\" или которые заканчиваются на буквосочетание \"ук\". \nГарантируется, что тюркизмы не повторяются.\nВ конце программа печатает количество всех тюркизмов, встречающихся в тексте. \nЕсли названий тюркизмов в тексте нет, программа печатает строку \"Тюркизмов в тексте нет\".", "correct_example": "sentence = input()\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nОткрыв сундук , исследователи увидели сюртук , который сиял как алмаз\nОжидаемый ответ:\n3\nОтвет решения:\n9\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "442": {"student_solution": "sentence = input()\n\nres = 0\nfor info in sentence.split():\n    if info.endswith('ук') or 'аз' in info:      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "task": "Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: \n\nВ переменную sentence считывается текст. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание \"аз\" или которые заканчиваются на буквосочетание \"ук\". \nГарантируется, что тюркизмы не повторяются.\nВ конце программа печатает количество всех тюркизмов, встречающихся в тексте. \nЕсли названий тюркизмов в тексте нет, программа печатает строку \"Тюркизмов в тексте нет\".", "correct_example": "sentence = input()\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nукрытие укор раз1бор луковица азы! зазор123\nОжидаемый ответ:\nТюркизмов в тексте нет\nОтвет решения:\n3\n\n", "error_on_open": false, "error_on_closed": true, "syntax_error": false}, "443": {"student_solution": "sentence = input()\n\nres = 0\nfor info in sentence.split():\n    if info.isalpha():      \n        res += 1\n    elif info.endswith('ук') or 'аз' in info:\n        res += 1\n\nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "task": "Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: \n\nВ переменную sentence считывается текст. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание \"аз\" или которые заканчиваются на буквосочетание \"ук\". \nГарантируется, что тюркизмы не повторяются.\nВ конце программа печатает количество всех тюркизмов, встречающихся в тексте. \nЕсли названий тюркизмов в тексте нет, программа печатает строку \"Тюркизмов в тексте нет\".", "correct_example": "sentence = input()\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nОткрыв сундук , исследователи увидели сюртук , который сиял как алмаз\nОжидаемый ответ:\n3\nОтвет решения:\n9\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "444": {"student_solution": "sentence = input()\n\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and info.endswith('ук'):      \n        res += 1\n    elif info.isalpha() and 'аз' in info:\n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "task": "Реализуйте программу, которая напечатает количество тюркизмов, встречающихся в тексте: \n\nВ переменную sentence считывается текст. Этот код уже написан.\nПрограмма проверяет, есть ли в этом тексте тюркизмы. Гарантируется, что тюркизмы — это всегда слова, которые отделены от другого текста пробелом, состоящие только из букв, в которых встречается буквосочетание \"аз\" или которые заканчиваются на буквосочетание \"ук\". \nГарантируется, что тюркизмы не повторяются.\nВ конце программа печатает количество всех тюркизмов, встречающихся в тексте. \nЕсли названий тюркизмов в тексте нет, программа печатает строку \"Тюркизмов в тексте нет\".", "correct_example": "sentence = input()\nres = 0\nfor info in sentence.split():\n    if info.isalpha() and (info.endswith('ук') or 'аз' in info):      \n        res += 1\n        \nif res == 0:\n    res = \"Тюркизмов в тексте нет\"\n\nprint(res)", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "445": {"student_solution": "course = input().split(', ')\nfavorite = input().split(', ')\nfree = input().split(', ')\n\nprint(*sorted(free&course&favorite, reverse = True), sep = '; ')", "task": "Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:\n\nВ переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.\nВ переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.\nВ переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.\nГарантируется, что языки в каждом списке уникальны.\nЛюбой список может оказаться пустым.\nПрограмма выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.\nЯзыки должны быть отсортированы в обратном алфавиту порядке.\nЕсли таких языков нет, программа ничего не выводит. ", "correct_example": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\nprint(*sorted(free&course&favorite, reverse = True), sep = '; ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nАнглийский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\11\\codefile.py\", line 6, in <module>\n    print(*sorted(free&course&favorite, reverse = True), sep = '; ')\nTypeError: unsupported operand type(s) for &: 'list' and 'list'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "446": {"student_solution": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\n\nprint(*sorted(free - course - favorite, reverse = True), sep = '; ')", "task": "Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:\n\nВ переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.\nВ переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.\nВ переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.\nГарантируется, что языки в каждом списке уникальны.\nЛюбой список может оказаться пустым.\nПрограмма выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.\nЯзыки должны быть отсортированы в обратном алфавиту порядке.\nЕсли таких языков нет, программа ничего не выводит. ", "correct_example": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\nprint(*sorted(free&course&favorite, reverse = True), sep = '; ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nАнглийский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский\nОжидаемый ответ:\nФранцузский; Китайский; Английский\nОтвет решения:\n\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "447": {"student_solution": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\n\nprint(*sorted(free - course & favorite, reverse = True), sep = '; ')", "task": "Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:\n\nВ переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.\nВ переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.\nВ переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.\nГарантируется, что языки в каждом списке уникальны.\nЛюбой список может оказаться пустым.\nПрограмма выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.\nЯзыки должны быть отсортированы в обратном алфавиту порядке.\nЕсли таких языков нет, программа ничего не выводит. ", "correct_example": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\nprint(*sorted(free&course&favorite, reverse = True), sep = '; ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nАнглийский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский\nОжидаемый ответ:\nФранцузский; Китайский; Английский\nОтвет решения:\n\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "448": {"student_solution": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\n\nprint(*sorted(course & favorite, reverse = True), sep = '; ')", "task": "Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:\n\nВ переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.\nВ переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.\nВ переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.\nГарантируется, что языки в каждом списке уникальны.\nЛюбой список может оказаться пустым.\nПрограмма выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.\nЯзыки должны быть отсортированы в обратном алфавиту порядке.\nЕсли таких языков нет, программа ничего не выводит. ", "correct_example": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\nprint(*sorted(free&course&favorite, reverse = True), sep = '; ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nАнглийский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский\nОжидаемый ответ:\nФранцузский; Китайский; Английский\nОтвет решения:\nФранцузский; Немецкий; Китайский; Английский\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "449": {"student_solution": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\n\nprint(*sorted(free & course, reverse = True), sep = '; ')", "task": "Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:\n\nВ переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.\nВ переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.\nВ переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.\nГарантируется, что языки в каждом списке уникальны.\nЛюбой список может оказаться пустым.\nПрограмма выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.\nЯзыки должны быть отсортированы в обратном алфавиту порядке.\nЕсли таких языков нет, программа ничего не выводит. ", "correct_example": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\nprint(*sorted(free&course&favorite, reverse = True), sep = '; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "450": {"student_solution": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\n\nprint(*sorted(free & cuorse & favorite, reverse = True), sep = '; ')", "task": "Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:\n\nВ переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.\nВ переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.\nВ переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.\nГарантируется, что языки в каждом списке уникальны.\nЛюбой список может оказаться пустым.\nПрограмма выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.\nЯзыки должны быть отсортированы в обратном алфавиту порядке.\nЕсли таких языков нет, программа ничего не выводит. ", "correct_example": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\nprint(*sorted(free&course&favorite, reverse = True), sep = '; ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nАнглийский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\11\\codefile.py\", line 6, in <module>\n    print(*sorted(free & cuorse & favorite, reverse = True), sep = '; ')\nNameError: name 'cuorse' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "451": {"student_solution": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\n\nprint(*sorted(free and course and favorite, reverse = True), sep = '; ')", "task": "Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:\n\nВ переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.\nВ переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.\nВ переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.\nГарантируется, что языки в каждом списке уникальны.\nЛюбой список может оказаться пустым.\nПрограмма выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.\nЯзыки должны быть отсортированы в обратном алфавиту порядке.\nЕсли таких языков нет, программа ничего не выводит. ", "correct_example": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\nprint(*sorted(free&course&favorite, reverse = True), sep = '; ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nАнглийский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский\nОжидаемый ответ:\nФранцузский; Китайский; Английский\nОтвет решения:\nФранцузский; Немецкий; Китайский; Английский\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "452": {"student_solution": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\n\nprint(*sorted(free + course + favorite, reverse = True), sep = '; ')", "task": "Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:\n\nВ переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.\nВ переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.\nВ переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.\nГарантируется, что языки в каждом списке уникальны.\nЛюбой список может оказаться пустым.\nПрограмма выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.\nЯзыки должны быть отсортированы в обратном алфавиту порядке.\nЕсли таких языков нет, программа ничего не выводит. ", "correct_example": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\nprint(*sorted(free&course&favorite, reverse = True), sep = '; ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nАнглийский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\11\\codefile.py\", line 6, in <module>\n    print(*sorted(free + course + favorite, reverse = True), sep = '; ')\nTypeError: unsupported operand type(s) for +: 'set' and 'set'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "453": {"student_solution": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\n\nprint(free & course & favorite)", "task": "Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:\n\nВ переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.\nВ переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.\nВ переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.\nГарантируется, что языки в каждом списке уникальны.\nЛюбой список может оказаться пустым.\nПрограмма выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.\nЯзыки должны быть отсортированы в обратном алфавиту порядке.\nЕсли таких языков нет, программа ничего не выводит. ", "correct_example": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\nprint(*sorted(free&course&favorite, reverse = True), sep = '; ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nАнглийский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский\nОжидаемый ответ:\nФранцузский; Китайский; Английский\nОтвет решения:\n{'Китайский', 'Английский', 'Французский'}\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "454": {"student_solution": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\n\nprint(*sorted(free & course & favorite))", "task": "Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:\n\nВ переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.\nВ переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.\nВ переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.\nГарантируется, что языки в каждом списке уникальны.\nЛюбой список может оказаться пустым.\nПрограмма выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.\nЯзыки должны быть отсортированы в обратном алфавиту порядке.\nЕсли таких языков нет, программа ничего не выводит. ", "correct_example": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\nprint(*sorted(free&course&favorite, reverse = True), sep = '; ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nАнглийский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский\nОжидаемый ответ:\nФранцузский; Китайский; Английский\nОтвет решения:\nАнглийский Китайский Французский\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "455": {"student_solution": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\n\nprint(*sorted(free & course & favorite), sep = '; ')", "task": "Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:\n\nВ переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.\nВ переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.\nВ переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.\nГарантируется, что языки в каждом списке уникальны.\nЛюбой список может оказаться пустым.\nПрограмма выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.\nЯзыки должны быть отсортированы в обратном алфавиту порядке.\nЕсли таких языков нет, программа ничего не выводит. ", "correct_example": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\nprint(*sorted(free&course&favorite, reverse = True), sep = '; ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nАнглийский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский\nОжидаемый ответ:\nФранцузский; Китайский; Английский\nОтвет решения:\nАнглийский; Китайский; Французский\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "456": {"student_solution": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\n\nprint(*sorted(free & course & favorite, reverse = True))", "task": "Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:\n\nВ переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.\nВ переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.\nВ переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.\nГарантируется, что языки в каждом списке уникальны.\nЛюбой список может оказаться пустым.\nПрограмма выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.\nЯзыки должны быть отсортированы в обратном алфавиту порядке.\nЕсли таких языков нет, программа ничего не выводит. ", "correct_example": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\nprint(*sorted(free&course&favorite, reverse = True), sep = '; ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nАнглийский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский\nОжидаемый ответ:\nФранцузский; Китайский; Английский\nОтвет решения:\nФранцузский Китайский Английский\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "457": {"student_solution": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\n\nprint(*sorted(free & course & favorite, reverse = true), sep = '; ')", "task": "Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:\n\nВ переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.\nВ переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.\nВ переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.\nГарантируется, что языки в каждом списке уникальны.\nЛюбой список может оказаться пустым.\nПрограмма выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.\nЯзыки должны быть отсортированы в обратном алфавиту порядке.\nЕсли таких языков нет, программа ничего не выводит. ", "correct_example": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\nprint(*sorted(free&course&favorite, reverse = True), sep = '; ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nАнглийский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\11\\codefile.py\", line 6, in <module>\n    print(*sorted(free & course & favorite, reverse = true), sep = '; ')\nNameError: name 'true' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "458": {"student_solution": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\n\nprint(*sorted(free & course & favorite, reverse = True), sep = '; ', end = '.')", "task": "Студент хочет определить языки, которые он будет изучать на втором курсе. Реализуйте программу, которая поможет ему сделать выбор:\n\nВ переменную course считывается список языков, которые изучаются в рамках учебной программы. Этот код уже написан.\nВ переменную favorite считывается список языков, которые нравятся студенту. Этот код уже написан.\nВ переменную free считывается список языков, которые можно изучать в университете бесплатно. Этот код уже написан.\nГарантируется, что языки в каждом списке уникальны.\nЛюбой список может оказаться пустым.\nПрограмма выводит через точку с запятой и пробел языки, которые изучаются в рамках программы, нравятся студенту и их можно изучать в университете бесплатно.\nЯзыки должны быть отсортированы в обратном алфавиту порядке.\nЕсли таких языков нет, программа ничего не выводит. ", "correct_example": "course = set(input().split(', '))\nfavorite = set(input().split(', '))\nfree = set(input().split(', '))\nprint(*sorted(free&course&favorite, reverse = True), sep = '; ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nАнглийский, Французский, Немецкий, Китайский, Арабский, Норвежский\nФранцузский, Немецкий, Английский, Китайский\nФранцузский, Английский, Китайский\nОжидаемый ответ:\nФранцузский; Китайский; Английский\nОтвет решения:\nФранцузский; Китайский; Английский.\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "459": {"student_solution": "language = input() \n\ncount_list = {}\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "task": "Реализуйте программу, определяющую переводчиков, которые знают определенные языки:\n\nДан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.\nВ переменную language считывается язык (строка). Этот код уже написан.\nОпределите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.\nЕсли язык никто не знает, то программа ничего не печатает.", "correct_example": "\nlanguage = input()\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nанглийский\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\12\\codefile.py\", line 12, in <module>\n    count_list.append(k.split()[0].upper())\nAttributeError: 'dict' object has no attribute 'append'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "460": {"student_solution": "language = input() \n\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "task": "Реализуйте программу, определяющую переводчиков, которые знают определенные языки:\n\nДан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.\nВ переменную language считывается язык (строка). Этот код уже написан.\nОпределите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.\nЕсли язык никто не знает, то программа ничего не печатает.", "correct_example": "\nlanguage = input()\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nанглийский\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\12\\codefile.py\", line 11, in <module>\n    count_list.append(k.split()[0].upper())\nNameError: name 'count_list' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "461": {"student_solution": "language = input() \n\ncount_list = []\nfor key, value in interpreter:\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "task": "Реализуйте программу, определяющую переводчиков, которые знают определенные языки:\n\nДан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.\nВ переменную language считывается язык (строка). Этот код уже написан.\nОпределите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.\nЕсли язык никто не знает, то программа ничего не печатает.", "correct_example": "\nlanguage = input()\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nанглийский\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\12\\codefile.py\", line 9, in <module>\n    for key, value in interpreter:\nValueError: too many values to unpack (expected 2)\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "462": {"student_solution": "language = input() \n\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value:\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "task": "Реализуйте программу, определяющую переводчиков, которые знают определенные языки:\n\nДан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.\nВ переменную language считывается язык (строка). Этот код уже написан.\nОпределите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.\nЕсли язык никто не знает, то программа ничего не печатает.", "correct_example": "\nlanguage = input()\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nанглийский\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\12\\codefile.py\", line 10, in <module>\n    for k, v in value:\nValueError: too many values to unpack (expected 2)\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "463": {"student_solution": "language = input() \n\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in key.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "task": "Реализуйте программу, определяющую переводчиков, которые знают определенные языки:\n\nДан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.\nВ переменную language считывается язык (строка). Этот код уже написан.\nОпределите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.\nЕсли язык никто не знает, то программа ничего не печатает.", "correct_example": "\nlanguage = input()\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nанглийский\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\12\\codefile.py\", line 10, in <module>\n    for k, v in key.items():\nAttributeError: 'str' object has no attribute 'items'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "464": {"student_solution": "language = input() \n\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "task": "Реализуйте программу, определяющую переводчиков, которые знают определенные языки:\n\nДан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.\nВ переменную language считывается язык (строка). Этот код уже написан.\nОпределите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.\nЕсли язык никто не знает, то программа ничего не печатает.", "correct_example": "\nlanguage = input()\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nанглийский\nОжидаемый ответ:\nИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ\nОтвет решения:\nПЕТРОВ; МАРТЫНОВ; ПРАВДИН; ИГНАТОВ\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "465": {"student_solution": "language = input() \n\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "task": "Реализуйте программу, определяющую переводчиков, которые знают определенные языки:\n\nДан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.\nВ переменную language считывается язык (строка). Этот код уже написан.\nОпределите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.\nЕсли язык никто не знает, то программа ничего не печатает.", "correct_example": "\nlanguage = input()\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nанглийский\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\12\\codefile.py\", line 11\n    if language not in v\n                        ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "466": {"student_solution": "language = input() \n\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.add(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "task": "Реализуйте программу, определяющую переводчиков, которые знают определенные языки:\n\nДан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.\nВ переменную language считывается язык (строка). Этот код уже написан.\nОпределите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.\nЕсли язык никто не знает, то программа ничего не печатает.", "correct_example": "\nlanguage = input()\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nанглийский\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\12\\codefile.py\", line 12, in <module>\n    count_list.add(k.split()[0].upper())\nAttributeError: 'list' object has no attribute 'add'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "467": {"student_solution": "language = input() \n\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k)\n    \nprint(*count_list, sep='; ')", "task": "Реализуйте программу, определяющую переводчиков, которые знают определенные языки:\n\nДан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.\nВ переменную language считывается язык (строка). Этот код уже написан.\nОпределите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.\nЕсли язык никто не знает, то программа ничего не печатает.", "correct_example": "\nlanguage = input()\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nанглийский\nОжидаемый ответ:\nИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ\nОтвет решения:\nИванов Кирилл; Раскин Николай; Родионов Олег; Громов Игорь\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "468": {"student_solution": "language = input() \n\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[1].upper())\n    \nprint(*count_list, sep='; ')", "task": "Реализуйте программу, определяющую переводчиков, которые знают определенные языки:\n\nДан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.\nВ переменную language считывается язык (строка). Этот код уже написан.\nОпределите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.\nЕсли язык никто не знает, то программа ничего не печатает.", "correct_example": "\nlanguage = input()\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nанглийский\nОжидаемый ответ:\nИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ\nОтвет решения:\nКИРИЛЛ; НИКОЛАЙ; ОЛЕГ; ИГОРЬ\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "469": {"student_solution": "language = input() \n\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0])\n    \nprint(*count_list, sep='; ')", "task": "Реализуйте программу, определяющую переводчиков, которые знают определенные языки:\n\nДан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.\nВ переменную language считывается язык (строка). Этот код уже написан.\nОпределите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.\nЕсли язык никто не знает, то программа ничего не печатает.", "correct_example": "\nlanguage = input()\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nанглийский\nОжидаемый ответ:\nИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ\nОтвет решения:\nИванов; Раскин; Родионов; Громов\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "470": {"student_solution": "language = input() \n\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(count_list)", "task": "Реализуйте программу, определяющую переводчиков, которые знают определенные языки:\n\nДан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.\nВ переменную language считывается язык (строка). Этот код уже написан.\nОпределите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.\nЕсли язык никто не знает, то программа ничего не печатает.", "correct_example": "\nlanguage = input()\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nанглийский\nОжидаемый ответ:\nИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ\nОтвет решения:\n['ИВАНОВ', 'РАСКИН', 'РОДИОНОВ', 'ГРОМОВ']\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "471": {"student_solution": "language = input() \n\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list)", "task": "Реализуйте программу, определяющую переводчиков, которые знают определенные языки:\n\nДан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.\nВ переменную language считывается язык (строка). Этот код уже написан.\nОпределите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.\nЕсли язык никто не знает, то программа ничего не печатает.", "correct_example": "\nlanguage = input()\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nанглийский\nОжидаемый ответ:\nИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ\nОтвет решения:\nИВАНОВ РАСКИН РОДИОНОВ ГРОМОВ\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "472": {"student_solution": "language = input() \n\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \n    print(*count_list, sep='; ')", "task": "Реализуйте программу, определяющую переводчиков, которые знают определенные языки:\n\nДан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.\nВ переменную language считывается язык (строка). Этот код уже написан.\nОпределите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.\nЕсли язык никто не знает, то программа ничего не печатает.", "correct_example": "\nlanguage = input()\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nанглийский\nОжидаемый ответ:\nИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ\nОтвет решения:\nИВАНОВ\nИВАНОВ; РАСКИН\nИВАНОВ; РАСКИН; РОДИОНОВ\nИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "473": {"student_solution": "language = input() \n\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*sorted(count_list), sep='; ')", "task": "Реализуйте программу, определяющую переводчиков, которые знают определенные языки:\n\nДан словарь interpreter, где ключи — это названия компаний, в которых работают переводчики, а значения — словари (где ключи — фамилии и имена переводчиков, разделенные пробелом, а значения — списки с языками, которые они знают). Этот код уже написан.\nВ переменную language считывается язык (строка). Этот код уже написан.\nОпределите, какие переводчики не знают введенный язык и напечатайте их фамилии в верхнем регистре через точку с запятой и пробел. Фамилии должны идти в том же порядке, что и в словаре.\nЕсли язык никто не знает, то программа ничего не печатает.", "correct_example": "\nlanguage = input()\ncount_list = []\nfor key, value in interpreter.items():\n    for k, v in value.items():\n        if language not in v:\n            count_list.append(k.split()[0].upper())\n    \nprint(*count_list, sep='; ')", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nанглийский\nОжидаемый ответ:\nИВАНОВ; РАСКИН; РОДИОНОВ; ГРОМОВ\nОтвет решения:\nГРОМОВ; ИВАНОВ; РАСКИН; РОДИОНОВ\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "474": {"student_solution": "def count_letters(langs, letters)\n    sp = []\n    langs = langs.split(', ')\n    letters = list(map(int, letters.split(', ')))\n    mn = min(letters)\n    ind = letters.index(mn)\n    return langs[ind]", "task": "Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.\n\nОпределите функцию count_letters, которая принимает на вход два аргумента:\nстроку, где через запятую и пробел перечислены языки;\nстроку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;\nГарантируется, что языки и количество букв не повторяются. \nФункция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def count_letters(langs, letters):\n    sp = []\n    langs = langs.split(', ')\n    letters = list(map(int, letters.split(', ')))\n    mn = min(letters)\n    ind = letters.index(mn)\n    return langs[ind]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29'\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\13\\codefile.py\", line 2\n    def count_letters(langs, letters)\n                                     ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "475": {"student_solution": "def count_letters():\n    sp = []\n    langs = langs.split(', ')\n    letters = list(map(int, letters.split(', ')))\n    mn = min(letters)\n    ind = letters.index(mn)\n    return langs[ind]", "task": "Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.\n\nОпределите функцию count_letters, которая принимает на вход два аргумента:\nстроку, где через запятую и пробел перечислены языки;\nстроку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;\nГарантируется, что языки и количество букв не повторяются. \nФункция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def count_letters(langs, letters):\n    sp = []\n    langs = langs.split(', ')\n    letters = list(map(int, letters.split(', ')))\n    mn = min(letters)\n    ind = letters.index(mn)\n    return langs[ind]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29'\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\13\\codefile.py\", line 9, in <module>\n    print(count_letters(langs, letters))\nTypeError: count_letters() takes 0 positional arguments but 2 were given\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "476": {"student_solution": "def count_letters(langs, letters):\n    langs = langs.split(', ')\n    letters = list(map(int, letters.split(', ')))\n    mn = min(letters)\n    ind = letters.index(mn)\n    return langs[ind]", "task": "Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.\n\nОпределите функцию count_letters, которая принимает на вход два аргумента:\nстроку, где через запятую и пробел перечислены языки;\nстроку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;\nГарантируется, что языки и количество букв не повторяются. \nФункция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def count_letters(langs, letters):\n    sp = []\n    langs = langs.split(', ')\n    letters = list(map(int, letters.split(', ')))\n    mn = min(letters)\n    ind = letters.index(mn)\n    return langs[ind]", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "477": {"student_solution": "def count_letters(langs, letters):\n    sp = []\n    langs = langs.split()\n    letters = list(map(int, letters.split(', ')))\n    mn = min(letters)\n    ind = letters.index(mn)\n    return langs[ind]", "task": "Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.\n\nОпределите функцию count_letters, которая принимает на вход два аргумента:\nстроку, где через запятую и пробел перечислены языки;\nстроку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;\nГарантируется, что языки и количество букв не повторяются. \nФункция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def count_letters(langs, letters):\n    sp = []\n    langs = langs.split(', ')\n    letters = list(map(int, letters.split(', ')))\n    mn = min(letters)\n    ind = letters.index(mn)\n    return langs[ind]", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29'\nОжидаемый ответ:\nанглийский\nОтвет решения:\nанглийский,\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "478": {"student_solution": "def count_letters(langs, letters):\n    sp = []\n    langs = langs.split(', ')\n    letters = list(map(int, letters))\n    mn = min(letters)\n    ind = letters.index(mn)\n    return langs[ind]", "task": "Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.\n\nОпределите функцию count_letters, которая принимает на вход два аргумента:\nстроку, где через запятую и пробел перечислены языки;\nстроку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;\nГарантируется, что языки и количество букв не повторяются. \nФункция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def count_letters(langs, letters):\n    sp = []\n    langs = langs.split(', ')\n    letters = list(map(int, letters.split(', ')))\n    mn = min(letters)\n    ind = letters.index(mn)\n    return langs[ind]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29'\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\13\\codefile.py\", line 9, in <module>\n    print(count_letters(langs, letters))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\13\\codefile.py\", line 5, in count_letters\n    letters = list(map(int, letters))\nValueError: invalid literal for int() with base 10: ','\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "479": {"student_solution": "def count_letters(langs, letters):\n    sp = []\n    langs = langs.split(', ')\n    letters = list(map(letters.split(', ')))\n    mn = min(letters)\n    ind = letters.index(mn)\n    return langs[ind]", "task": "Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.\n\nОпределите функцию count_letters, которая принимает на вход два аргумента:\nстроку, где через запятую и пробел перечислены языки;\nстроку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;\nГарантируется, что языки и количество букв не повторяются. \nФункция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def count_letters(langs, letters):\n    sp = []\n    langs = langs.split(', ')\n    letters = list(map(int, letters.split(', ')))\n    mn = min(letters)\n    ind = letters.index(mn)\n    return langs[ind]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29'\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\13\\codefile.py\", line 9, in <module>\n    print(count_letters(langs, letters))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\13\\codefile.py\", line 5, in count_letters\n    letters = list(map(letters.split(', ')))\nTypeError: map() must have at least two arguments.\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "480": {"student_solution": "def count_letters(langs, letters):\n    sp = []\n    langs = langs.split(', ')\n    letters = list(map(int, letters.split(', ')))\n    mn = min(letters)\n    ind = letters.index(mn)\n    print(langs[ind])", "task": "Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.\n\nОпределите функцию count_letters, которая принимает на вход два аргумента:\nстроку, где через запятую и пробел перечислены языки;\nстроку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;\nГарантируется, что языки и количество букв не повторяются. \nФункция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def count_letters(langs, letters):\n    sp = []\n    langs = langs.split(', ')\n    letters = list(map(int, letters.split(', ')))\n    mn = min(letters)\n    ind = letters.index(mn)\n    return langs[ind]", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29'\nОжидаемый ответ:\nанглийский\nОтвет решения:\nанглийский\nNone\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "481": {"student_solution": "def count_letters(langs, letters):\n    sp = []\n    langs = langs.split(', ')\n    letters = list(map(int, letters.split(', ')))\n    mn = min(letters)\n    ind = letters.index(mn)\n    return ind", "task": "Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.\n\nОпределите функцию count_letters, которая принимает на вход два аргумента:\nстроку, где через запятую и пробел перечислены языки;\nстроку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;\nГарантируется, что языки и количество букв не повторяются. \nФункция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def count_letters(langs, letters):\n    sp = []\n    langs = langs.split(', ')\n    letters = list(map(int, letters.split(', ')))\n    mn = min(letters)\n    ind = letters.index(mn)\n    return langs[ind]", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29'\nОжидаемый ответ:\nанглийский\nОтвет решения:\n0\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "482": {"student_solution": "def count_letters(langs, letters):\n    sp = []\n    langs = langs.split(', ')\n    letters = list(map(int, letters.split(', ')))\n    ind = letters.index(letters)\n    return langs[ind]", "task": "Витя хочет определить язык, алфавит которого состоит из минимального количества букв. Напишите функцию, которая ему в этом поможет.\n\nОпределите функцию count_letters, которая принимает на вход два аргумента:\nстроку, где через запятую и пробел перечислены языки;\nстроку, где через запятую и пробел перечислены числа, обозначающие количество букв в алфавите каждого языка;\nГарантируется, что языки и количество букв не повторяются. \nФункция должна возвращать строку — название языка, в алфавите которого минимальное количество букв. \nВажно! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.", "correct_example": "def count_letters(langs, letters):\n    sp = []\n    langs = langs.split(', ')\n    letters = list(map(int, letters.split(', ')))\n    mn = min(letters)\n    ind = letters.index(mn)\n    return langs[ind]", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n'английский, казахский, русский, испанский, польский', '26, 42, 33, 27, 29'\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\13\\codefile.py\", line 8, in <module>\n    print(count_letters(langs, letters))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\13\\codefile.py\", line 6, in count_letters\n    ind = letters.index(letters)\nValueError: [26, 42, 33, 27, 29] is not in list\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "501": {"student_solution": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = '{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "task": "Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. \n\nФОРМАТ ВВОДА \nВводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (\"/\"). \nГарантируется, что каждая строка состоит из информации минимум об одной главе.\nФОРМАТ ВЫВОДА \nЦелое число — минимальное число слов, встречающееся в трех разделах книги. \nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.\nСоздайте переменную-счетчик для определения минимального количества слов.\nРазбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.\nНапечатайте значение переменной-счетчика.", "correct_example": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nИстория, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\14\\codefile.py\", line 11, in <module>\n    item = int(item.split(': ')[1].split()[0])\nIndexError: list index out of range\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "502": {"student_solution": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "task": "Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. \n\nФОРМАТ ВВОДА \nВводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (\"/\"). \nГарантируется, что каждая строка состоит из информации минимум об одной главе.\nФОРМАТ ВЫВОДА \nЦелое число — минимальное число слов, встречающееся в трех разделах книги. \nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.\nСоздайте переменную-счетчик для определения минимального количества слов.\nРазбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.\nНапечатайте значение переменной-счетчика.", "correct_example": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nИстория, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\14\\codefile.py\", line 6\n    res = f'{ch1}/{ch2}/{ch3}.split('/')\n                                        ^\nSyntaxError: EOL while scanning string literal\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "503": {"student_solution": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "task": "Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. \n\nФОРМАТ ВВОДА \nВводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (\"/\"). \nГарантируется, что каждая строка состоит из информации минимум об одной главе.\nФОРМАТ ВЫВОДА \nЦелое число — минимальное число слов, встречающееся в трех разделах книги. \nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.\nСоздайте переменную-счетчик для определения минимального количества слов.\nРазбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.\nНапечатайте значение переменной-счетчика.", "correct_example": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nИстория, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\14\\codefile.py\", line 6\n    res = f{ch1}/{ch2}/{ch3}'.split('/')\n           ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "504": {"student_solution": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch}/{ch1}/{ch2}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "task": "Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. \n\nФОРМАТ ВВОДА \nВводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (\"/\"). \nГарантируется, что каждая строка состоит из информации минимум об одной главе.\nФОРМАТ ВЫВОДА \nЦелое число — минимальное число слов, встречающееся в трех разделах книги. \nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.\nСоздайте переменную-счетчик для определения минимального количества слов.\nРазбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.\nНапечатайте значение переменной-счетчика.", "correct_example": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nИстория, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\14\\codefile.py\", line 6, in <module>\n    res = f'{ch}/{ch1}/{ch2}'.split('/')\nNameError: name 'ch' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "505": {"student_solution": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split()\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "task": "Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. \n\nФОРМАТ ВВОДА \nВводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (\"/\"). \nГарантируется, что каждая строка состоит из информации минимум об одной главе.\nФОРМАТ ВЫВОДА \nЦелое число — минимальное число слов, встречающееся в трех разделах книги. \nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.\nСоздайте переменную-счетчик для определения минимального количества слов.\nРазбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.\nНапечатайте значение переменной-счетчика.", "correct_example": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nИстория, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\14\\codefile.py\", line 11, in <module>\n    item = int(item.split(': ')[1].split()[0])\nIndexError: list index out of range\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "506": {"student_solution": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "task": "Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. \n\nФОРМАТ ВВОДА \nВводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (\"/\"). \nГарантируется, что каждая строка состоит из информации минимум об одной главе.\nФОРМАТ ВЫВОДА \nЦелое число — минимальное число слов, встречающееся в трех разделах книги. \nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.\nСоздайте переменную-счетчик для определения минимального количества слов.\nРазбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.\nНапечатайте значение переменной-счетчика.", "correct_example": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nИстория, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\14\\codefile.py\", line 11, in <module>\n    item = int(item.split(': ')[1].split()[0])\nIndexError: list index out of range\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "507": {"student_solution": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor i in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "task": "Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. \n\nФОРМАТ ВВОДА \nВводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (\"/\"). \nГарантируется, что каждая строка состоит из информации минимум об одной главе.\nФОРМАТ ВЫВОДА \nЦелое число — минимальное число слов, встречающееся в трех разделах книги. \nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.\nСоздайте переменную-счетчик для определения минимального количества слов.\nРазбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.\nНапечатайте значение переменной-счетчика.", "correct_example": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nИстория, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\14\\codefile.py\", line 11, in <module>\n    item = int(item.split(': ')[1].split()[0])\nNameError: name 'item' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "508": {"student_solution": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "task": "Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. \n\nФОРМАТ ВВОДА \nВводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (\"/\"). \nГарантируется, что каждая строка состоит из информации минимум об одной главе.\nФОРМАТ ВЫВОДА \nЦелое число — минимальное число слов, встречающееся в трех разделах книги. \nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.\nСоздайте переменную-счетчик для определения минимального количества слов.\nРазбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.\nНапечатайте значение переменной-счетчика.", "correct_example": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nИстория, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\14\\codefile.py\", line 10\n    for item in res\n                   ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "509": {"student_solution": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = item.split(': ')[1].split()[0]\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "task": "Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. \n\nФОРМАТ ВВОДА \nВводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (\"/\"). \nГарантируется, что каждая строка состоит из информации минимум об одной главе.\nФОРМАТ ВЫВОДА \nЦелое число — минимальное число слов, встречающееся в трех разделах книги. \nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.\nСоздайте переменную-счетчик для определения минимального количества слов.\nРазбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.\nНапечатайте значение переменной-счетчика.", "correct_example": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nИстория, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\14\\codefile.py\", line 13, in <module>\n    if item < counter:\nTypeError: '<' not supported between instances of 'str' and 'int'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "510": {"student_solution": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split('; ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "task": "Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. \n\nФОРМАТ ВВОДА \nВводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (\"/\"). \nГарантируется, что каждая строка состоит из информации минимум об одной главе.\nФОРМАТ ВЫВОДА \nЦелое число — минимальное число слов, встречающееся в трех разделах книги. \nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.\nСоздайте переменную-счетчик для определения минимального количества слов.\nРазбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.\nНапечатайте значение переменной-счетчика.", "correct_example": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nИстория, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\14\\codefile.py\", line 11, in <module>\n    item = int(item.split('; ')[1].split()[0])\nIndexError: list index out of range\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "511": {"student_solution": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[2].split()[1])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "task": "Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. \n\nФОРМАТ ВВОДА \nВводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (\"/\"). \nГарантируется, что каждая строка состоит из информации минимум об одной главе.\nФОРМАТ ВЫВОДА \nЦелое число — минимальное число слов, встречающееся в трех разделах книги. \nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.\nСоздайте переменную-счетчик для определения минимального количества слов.\nРазбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.\nНапечатайте значение переменной-счетчика.", "correct_example": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nИстория, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\14\\codefile.py\", line 11, in <module>\n    item = int(item.split(': ')[2].split()[1])\nIndexError: list index out of range\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "512": {"student_solution": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "task": "Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. \n\nФОРМАТ ВВОДА \nВводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (\"/\"). \nГарантируется, что каждая строка состоит из информации минимум об одной главе.\nФОРМАТ ВЫВОДА \nЦелое число — минимальное число слов, встречающееся в трех разделах книги. \nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.\nСоздайте переменную-счетчик для определения минимального количества слов.\nРазбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.\nНапечатайте значение переменной-счетчика.", "correct_example": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nИстория, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\14\\codefile.py\", line 11, in <module>\n    item = int(item.split(': ')[1])\nValueError: invalid literal for int() with base 10: '50000 слов'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "513": {"student_solution": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item <= counter:\n        counter = item\n    \nprint(counter)", "task": "Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. \n\nФОРМАТ ВВОДА \nВводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (\"/\"). \nГарантируется, что каждая строка состоит из информации минимум об одной главе.\nФОРМАТ ВЫВОДА \nЦелое число — минимальное число слов, встречающееся в трех разделах книги. \nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.\nСоздайте переменную-счетчик для определения минимального количества слов.\nРазбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.\nНапечатайте значение переменной-счетчика.", "correct_example": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "514": {"student_solution": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item > counter:\n        counter = item\n    \nprint(counter)", "task": "Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. \n\nФОРМАТ ВВОДА \nВводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (\"/\"). \nГарантируется, что каждая строка состоит из информации минимум об одной главе.\nФОРМАТ ВЫВОДА \nЦелое число — минимальное число слов, встречающееся в трех разделах книги. \nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.\nСоздайте переменную-счетчик для определения минимального количества слов.\nРазбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.\nНапечатайте значение переменной-счетчика.", "correct_example": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nИстория, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов\nОжидаемый ответ:\n15000\nОтвет решения:\n10000000\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "515": {"student_solution": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter == item\n    \nprint(counter)", "task": "Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. \n\nФОРМАТ ВВОДА \nВводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (\"/\"). \nГарантируется, что каждая строка состоит из информации минимум об одной главе.\nФОРМАТ ВЫВОДА \nЦелое число — минимальное число слов, встречающееся в трех разделах книги. \nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.\nСоздайте переменную-счетчик для определения минимального количества слов.\nРазбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.\nНапечатайте значение переменной-счетчика.", "correct_example": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nИстория, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов\nОжидаемый ответ:\n15000\nОтвет решения:\n10000000\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "516": {"student_solution": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(item)", "task": "Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. \n\nФОРМАТ ВВОДА \nВводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (\"/\"). \nГарантируется, что каждая строка состоит из информации минимум об одной главе.\nФОРМАТ ВЫВОДА \nЦелое число — минимальное число слов, встречающееся в трех разделах книги. \nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.\nСоздайте переменную-счетчик для определения минимального количества слов.\nРазбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.\nНапечатайте значение переменной-счетчика.", "correct_example": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nИстория, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов\nОжидаемый ответ:\n15000\nОтвет решения:\n60000\n\n", "error_on_open": true, "error_on_closed": false, "syntax_error": false}, "517": {"student_solution": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \n    print(counter)", "task": "Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. \n\nФОРМАТ ВВОДА \nВводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (\"/\"). \nГарантируется, что каждая строка состоит из информации минимум об одной главе.\nФОРМАТ ВЫВОДА \nЦелое число — минимальное число слов, встречающееся в трех разделах книги. \nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.\nСоздайте переменную-счетчик для определения минимального количества слов.\nРазбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.\nНапечатайте значение переменной-счетчика.", "correct_example": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nИстория, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов\nОжидаемый ответ:\n15000\nОтвет решения:\n50000\n30000\n30000\n15000\n15000\n15000\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "518": {"student_solution": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\nif item < counter:\n    counter = item\n    \nprint(counter)", "task": "Мария хочет проверить, какое минимальное количество слов встречается в трех разделах книги. Напишите программу, которая поможет девушке. \n\nФОРМАТ ВВОДА \nВводятся три строки (за каждый раздел книги) в формате '<название главы>: <количество слов> слов'.  Между собой информация о главах разделена прямым слэшем (\"/\"). \nГарантируется, что каждая строка состоит из информации минимум об одной главе.\nФОРМАТ ВЫВОДА \nЦелое число — минимальное число слов, встречающееся в трех разделах книги. \nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСчитайте строки в три разных переменных. Затем объедините эти строки в одну, в качестве разделителя используйте прямой слэш. Сохраните результат в новую переменную.\nСоздайте переменную-счетчик для определения минимального количества слов.\nРазбейте созданную в п.1 переменную по разделителю и обратитесь к каждому элементу полученного списка — из каждой строки вытащите количество слов (не забудьте преобразовать в целое число). Если данное значение числа слов меньше переменной-счетчика, то обновите переменную-счетчик.\nНапечатайте значение переменной-счетчика.", "correct_example": "ch1 = input()\nch2 = input()\nch3 = input()\n\nres = f'{ch1}/{ch2}/{ch3}'.split('/')\n\ncounter = 10000000\n\nfor item in res:\n    item = int(item.split(': ')[1].split()[0])\n\n    if item < counter:\n        counter = item\n    \nprint(counter)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nИстория, литература и искусство древнего периода: 50000 слов/История и искусство XI - XIII вв.: 30000 слов/История, литература и искусство конца XIII - XV в.: 90000 слов\nИстория, литература и искусство тюдоровского периода: 15000 слов\nСемнадцатый век: 50000 слов/Восемнадцатый век: 60000 слов\nОжидаемый ответ:\n15000\nОтвет решения:\n60000\n\n", "error_on_open": true, "error_on_closed": false, "syntax_error": false}, "537": {"student_solution": "def text_check(data)\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n            \n    if counter != 0:\n        return ([True, summa])\n        \n    return False", "task": "Напишите функцию, определяющую можно считать книгу переведенной или нет. \n\nТРЕБУЕМАЯ ФУНКЦИЯ \nФункция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой \"переведена\" или \"не переведена\"). Гарантируется, что словарь содержит информацию минимум об одной главе.\nЕсли хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.\nЕсли все главы не были переведены, то функция возвращает логическую константу False.\nВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nОпределите функцию и аргумент, с которым она работает.\nЗадайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк \"переведена\".\nОбратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение \"переведена\", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.\nПроверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.", "correct_example": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n\n    if counter != 0:\n        return ([True, summa])\n\n    return False", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n{    'Глава 1': (3000, 'не переведена'),     'Глава 2': (2000, 'не переведена'),     'Глава 3': (10000, 'не переведена'),     'Глава 4': (6000, 'не переведена'),  'Глава 5': (6500, 'не переведена')}\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\15\\codefile.py\", line 2\n    def text_check(data)\n                        ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "538": {"student_solution": "def text_check():\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n            \n    if counter != 0:\n        return ([True, summa])\n        \n    return False", "task": "Напишите функцию, определяющую можно считать книгу переведенной или нет. \n\nТРЕБУЕМАЯ ФУНКЦИЯ \nФункция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой \"переведена\" или \"не переведена\"). Гарантируется, что словарь содержит информацию минимум об одной главе.\nЕсли хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.\nЕсли все главы не были переведены, то функция возвращает логическую константу False.\nВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nОпределите функцию и аргумент, с которым она работает.\nЗадайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк \"переведена\".\nОбратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение \"переведена\", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.\nПроверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.", "correct_example": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n\n    if counter != 0:\n        return ([True, summa])\n\n    return False", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n{    'Глава 1': (3000, 'не переведена'),     'Глава 2': (2000, 'не переведена'),     'Глава 3': (10000, 'не переведена'),     'Глава 4': (6000, 'не переведена'),  'Глава 5': (6500, 'не переведена')}\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\15\\codefile.py\", line 14, in <module>\n    print(text_check(data))\nTypeError: text_check() takes 0 positional arguments but 1 was given\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "539": {"student_solution": "def text_check(data):\n    counter = 0\n    summ = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n            \n    if counter != 0:\n        return ([True, summa])\n        \n    return False", "task": "Напишите функцию, определяющую можно считать книгу переведенной или нет. \n\nТРЕБУЕМАЯ ФУНКЦИЯ \nФункция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой \"переведена\" или \"не переведена\"). Гарантируется, что словарь содержит информацию минимум об одной главе.\nЕсли хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.\nЕсли все главы не были переведены, то функция возвращает логическую константу False.\nВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nОпределите функцию и аргумент, с которым она работает.\nЗадайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк \"переведена\".\nОбратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение \"переведена\", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.\nПроверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.", "correct_example": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n\n    if counter != 0:\n        return ([True, summa])\n\n    return False", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n{    'Героический эпос народов СССР. № 1': (100000, 'переведена'),    'Героический эпос народов СССР. № 2': (1005, 'не переведена')}\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\15\\codefile.py\", line 14, in <module>\n    print(text_check(data))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\15\\codefile.py\", line 8, in text_check\n    summa += v[0]\nUnboundLocalError: local variable 'summa' referenced before assignment\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "540": {"student_solution": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data:\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n            \n    if counter != 0:\n        return ([True, summa])\n        \n    return False", "task": "Напишите функцию, определяющую можно считать книгу переведенной или нет. \n\nТРЕБУЕМАЯ ФУНКЦИЯ \nФункция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой \"переведена\" или \"не переведена\"). Гарантируется, что словарь содержит информацию минимум об одной главе.\nЕсли хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.\nЕсли все главы не были переведены, то функция возвращает логическую константу False.\nВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nОпределите функцию и аргумент, с которым она работает.\nЗадайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк \"переведена\".\nОбратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение \"переведена\", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.\nПроверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.", "correct_example": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n\n    if counter != 0:\n        return ([True, summa])\n\n    return False", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n{    'Глава 1': (3000, 'не переведена'),     'Глава 2': (2000, 'не переведена'),     'Глава 3': (10000, 'не переведена'),     'Глава 4': (6000, 'не переведена'),  'Глава 5': (6500, 'не переведена')}\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\15\\codefile.py\", line 14, in <module>\n    print(text_check(data))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\15\\codefile.py\", line 5, in text_check\n    for k, v in data:\nValueError: too many values to unpack (expected 2)\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "541": {"student_solution": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if k[1] == 'переведена':\n            counter += 1\n            summa += k[0]\n            \n    if counter != 0:\n        return ([True, summa])\n        \n    return False", "task": "Напишите функцию, определяющую можно считать книгу переведенной или нет. \n\nТРЕБУЕМАЯ ФУНКЦИЯ \nФункция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой \"переведена\" или \"не переведена\"). Гарантируется, что словарь содержит информацию минимум об одной главе.\nЕсли хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.\nЕсли все главы не были переведены, то функция возвращает логическую константу False.\nВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nОпределите функцию и аргумент, с которым она работает.\nЗадайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк \"переведена\".\nОбратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение \"переведена\", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.\nПроверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.", "correct_example": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n\n    if counter != 0:\n        return ([True, summa])\n\n    return False", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n{    'Героический эпос народов СССР. № 1': (100000, 'переведена'),    'Героический эпос народов СССР. № 2': (1005, 'не переведена')}\nОжидаемый ответ:\n[True, 100000]\nОтвет решения:\nFalse\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "542": {"student_solution": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[2] == 'переведена':\n            counter += 1\n            summa += v[1]\n            \n    if counter != 0:\n        return ([True, summa])\n        \n    return False", "task": "Напишите функцию, определяющую можно считать книгу переведенной или нет. \n\nТРЕБУЕМАЯ ФУНКЦИЯ \nФункция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой \"переведена\" или \"не переведена\"). Гарантируется, что словарь содержит информацию минимум об одной главе.\nЕсли хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.\nЕсли все главы не были переведены, то функция возвращает логическую константу False.\nВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nОпределите функцию и аргумент, с которым она работает.\nЗадайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк \"переведена\".\nОбратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение \"переведена\", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.\nПроверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.", "correct_example": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n\n    if counter != 0:\n        return ([True, summa])\n\n    return False", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n{    'Глава 1': (3000, 'не переведена'),     'Глава 2': (2000, 'не переведена'),     'Глава 3': (10000, 'не переведена'),     'Глава 4': (6000, 'не переведена'),  'Глава 5': (6500, 'не переведена')}\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\15\\codefile.py\", line 14, in <module>\n    print(text_check(data))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\15\\codefile.py\", line 6, in text_check\n    if v[2] == 'переведена':\nIndexError: tuple index out of range\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "543": {"student_solution": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] = 'переведена':\n            counter += 1\n            summa += v[0]\n            \n    if counter != 0:\n        return ([True, summa])\n        \n    return False", "task": "Напишите функцию, определяющую можно считать книгу переведенной или нет. \n\nТРЕБУЕМАЯ ФУНКЦИЯ \nФункция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой \"переведена\" или \"не переведена\"). Гарантируется, что словарь содержит информацию минимум об одной главе.\nЕсли хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.\nЕсли все главы не были переведены, то функция возвращает логическую константу False.\nВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nОпределите функцию и аргумент, с которым она работает.\nЗадайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк \"переведена\".\nОбратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение \"переведена\", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.\nПроверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.", "correct_example": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n\n    if counter != 0:\n        return ([True, summa])\n\n    return False", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n{    'Глава 1': (3000, 'не переведена'),     'Глава 2': (2000, 'не переведена'),     'Глава 3': (10000, 'не переведена'),     'Глава 4': (6000, 'не переведена'),  'Глава 5': (6500, 'не переведена')}\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\15\\codefile.py\", line 6\n    if v[1] = 'переведена':\n            ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "544": {"student_solution": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == переведена:\n            counter += 1\n            summa += v[0]\n            \n    if counter != 0:\n        return ([True, summa])\n        \n    return False", "task": "Напишите функцию, определяющую можно считать книгу переведенной или нет. \n\nТРЕБУЕМАЯ ФУНКЦИЯ \nФункция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой \"переведена\" или \"не переведена\"). Гарантируется, что словарь содержит информацию минимум об одной главе.\nЕсли хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.\nЕсли все главы не были переведены, то функция возвращает логическую константу False.\nВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nОпределите функцию и аргумент, с которым она работает.\nЗадайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк \"переведена\".\nОбратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение \"переведена\", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.\nПроверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.", "correct_example": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n\n    if counter != 0:\n        return ([True, summa])\n\n    return False", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n{    'Глава 1': (3000, 'не переведена'),     'Глава 2': (2000, 'не переведена'),     'Глава 3': (10000, 'не переведена'),     'Глава 4': (6000, 'не переведена'),  'Глава 5': (6500, 'не переведена')}\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\15\\codefile.py\", line 14, in <module>\n    print(text_check(data))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\15\\codefile.py\", line 6, in text_check\n    if v[1] == переведена:\nNameError: name 'переведена' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "545": {"student_solution": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] != 'переведена':\n            counter += 1\n            summa += v[0]\n            \n    if counter != 0:\n        return ([True, summa])\n        \n    return False", "task": "Напишите функцию, определяющую можно считать книгу переведенной или нет. \n\nТРЕБУЕМАЯ ФУНКЦИЯ \nФункция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой \"переведена\" или \"не переведена\"). Гарантируется, что словарь содержит информацию минимум об одной главе.\nЕсли хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.\nЕсли все главы не были переведены, то функция возвращает логическую константу False.\nВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nОпределите функцию и аргумент, с которым она работает.\nЗадайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк \"переведена\".\nОбратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение \"переведена\", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.\nПроверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.", "correct_example": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n\n    if counter != 0:\n        return ([True, summa])\n\n    return False", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n{    'Глава 1': (3000, 'не переведена'),     'Глава 2': (2000, 'не переведена'),     'Глава 3': (10000, 'не переведена'),     'Глава 4': (6000, 'не переведена'),  'Глава 5': (6500, 'не переведена')}\nОжидаемый ответ:\nFalse\nОтвет решения:\n[True, 27500]\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "546": {"student_solution": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n            \n    if counter != 0:\n        return ([False, summa])\n        \n    return True", "task": "Напишите функцию, определяющую можно считать книгу переведенной или нет. \n\nТРЕБУЕМАЯ ФУНКЦИЯ \nФункция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой \"переведена\" или \"не переведена\"). Гарантируется, что словарь содержит информацию минимум об одной главе.\nЕсли хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.\nЕсли все главы не были переведены, то функция возвращает логическую константу False.\nВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nОпределите функцию и аргумент, с которым она работает.\nЗадайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк \"переведена\".\nОбратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение \"переведена\", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.\nПроверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.", "correct_example": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n\n    if counter != 0:\n        return ([True, summa])\n\n    return False", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n{    'Глава 1': (3000, 'не переведена'),     'Глава 2': (2000, 'не переведена'),     'Глава 3': (10000, 'не переведена'),     'Глава 4': (6000, 'не переведена'),  'Глава 5': (6500, 'не переведена')}\nОжидаемый ответ:\nFalse\nОтвет решения:\nTrue\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "547": {"student_solution": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n            \n    if counter != 0:\n        return ([summa, True])\n        \n    return False", "task": "Напишите функцию, определяющую можно считать книгу переведенной или нет. \n\nТРЕБУЕМАЯ ФУНКЦИЯ \nФункция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой \"переведена\" или \"не переведена\"). Гарантируется, что словарь содержит информацию минимум об одной главе.\nЕсли хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.\nЕсли все главы не были переведены, то функция возвращает логическую константу False.\nВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nОпределите функцию и аргумент, с которым она работает.\nЗадайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк \"переведена\".\nОбратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение \"переведена\", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.\nПроверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.", "correct_example": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n\n    if counter != 0:\n        return ([True, summa])\n\n    return False", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n{    'Героический эпос народов СССР. № 1': (100000, 'переведена'),    'Героический эпос народов СССР. № 2': (1005, 'не переведена')}\nОжидаемый ответ:\n[True, 100000]\nОтвет решения:\n[100000, True]\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "548": {"student_solution": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa == v[0]\n            \n    if counter != 0:\n        return ([True, summa])\n        \n    return False", "task": "Напишите функцию, определяющую можно считать книгу переведенной или нет. \n\nТРЕБУЕМАЯ ФУНКЦИЯ \nФункция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой \"переведена\" или \"не переведена\"). Гарантируется, что словарь содержит информацию минимум об одной главе.\nЕсли хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.\nЕсли все главы не были переведены, то функция возвращает логическую константу False.\nВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nОпределите функцию и аргумент, с которым она работает.\nЗадайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк \"переведена\".\nОбратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение \"переведена\", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.\nПроверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.", "correct_example": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n\n    if counter != 0:\n        return ([True, summa])\n\n    return False", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n{    'Героический эпос народов СССР. № 1': (100000, 'переведена'),    'Героический эпос народов СССР. № 2': (1005, 'не переведена')}\nОжидаемый ответ:\n[True, 100000]\nОтвет решения:\n[True, 0]\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "549": {"student_solution": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n            \n    if counter != 0:\n        print([True, summa])\n        \n    print(False)", "task": "Напишите функцию, определяющую можно считать книгу переведенной или нет. \n\nТРЕБУЕМАЯ ФУНКЦИЯ \nФункция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой \"переведена\" или \"не переведена\"). Гарантируется, что словарь содержит информацию минимум об одной главе.\nЕсли хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.\nЕсли все главы не были переведены, то функция возвращает логическую константу False.\nВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nОпределите функцию и аргумент, с которым она работает.\nЗадайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк \"переведена\".\nОбратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение \"переведена\", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.\nПроверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.", "correct_example": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n\n    if counter != 0:\n        return ([True, summa])\n\n    return False", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n{    'Глава 1': (3000, 'не переведена'),     'Глава 2': (2000, 'не переведена'),     'Глава 3': (10000, 'не переведена'),     'Глава 4': (6000, 'не переведена'),  'Глава 5': (6500, 'не переведена')}\nОжидаемый ответ:\nFalse\nОтвет решения:\nFalse\nNone\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "550": {"student_solution": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n            \n    if counter != 0:\n        return ([true, summa])\n        \n    return false", "task": "Напишите функцию, определяющую можно считать книгу переведенной или нет. \n\nТРЕБУЕМАЯ ФУНКЦИЯ \nФункция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой \"переведена\" или \"не переведена\"). Гарантируется, что словарь содержит информацию минимум об одной главе.\nЕсли хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.\nЕсли все главы не были переведены, то функция возвращает логическую константу False.\nВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nОпределите функцию и аргумент, с которым она работает.\nЗадайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк \"переведена\".\nОбратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение \"переведена\", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.\nПроверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.", "correct_example": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n\n    if counter != 0:\n        return ([True, summa])\n\n    return False", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n{    'Глава 1': (3000, 'не переведена'),     'Глава 2': (2000, 'не переведена'),     'Глава 3': (10000, 'не переведена'),     'Глава 4': (6000, 'не переведена'),  'Глава 5': (6500, 'не переведена')}\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\15\\codefile.py\", line 14, in <module>\n    print(text_check(data))\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\15\\codefile.py\", line 13, in text_check\n    return false\nNameError: name 'false' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "551": {"student_solution": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n            \n        if counter != 0:\n            return ([True, summa])\n        \n    return False", "task": "Напишите функцию, определяющую можно считать книгу переведенной или нет. \n\nТРЕБУЕМАЯ ФУНКЦИЯ \nФункция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой \"переведена\" или \"не переведена\"). Гарантируется, что словарь содержит информацию минимум об одной главе.\nЕсли хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.\nЕсли все главы не были переведены, то функция возвращает логическую константу False.\nВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nОпределите функцию и аргумент, с которым она работает.\nЗадайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк \"переведена\".\nОбратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение \"переведена\", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.\nПроверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.", "correct_example": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n\n    if counter != 0:\n        return ([True, summa])\n\n    return False", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n{    'Арабская поэзия средних веков': (1092, 'не переведена'),    'Ирано-таджикская поэзия': (10090, 'переведена'),    'Средневековый роман и повесть': (2198, 'переведена')}\nОжидаемый ответ:\n[True, 12288]\nОтвет решения:\n[True, 10090]\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "552": {"student_solution": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n            \n    if counter != 0:\n        return (True, summa)\n        \n    return False", "task": "Напишите функцию, определяющую можно считать книгу переведенной или нет. \n\nТРЕБУЕМАЯ ФУНКЦИЯ \nФункция text_check, принимающая на вход словарь, ключи в котором — названия глав (строки), а значения — кортежи с двумя элементами (целым числом — количеством слов в главе; и строкой \"переведена\" или \"не переведена\"). Гарантируется, что словарь содержит информацию минимум об одной главе.\nЕсли хотя бы одна глава была переведена, то функция должна возвращать список из двух значений: логической константы True и целого числа — количества слов в главах, которые были переведены.\nЕсли все главы не были переведены, то функция возвращает логическую константу False.\nВАЖНО! В этой задаче вы только определяете функцию, вызывать ее и считывать значения не нужно, это произойдет автоматически при проверке.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nОпределите функцию и аргумент, с которым она работает.\nЗадайте две переменные-счетчика — одну для подсчета количества слов, другую для подсчета количества строк \"переведена\".\nОбратитесь к парам ключ-значение в переданном функции словаре. Если первый по индексу элемент значения (кортежа) принимает значение \"переведена\", то прибавьте 1 к первой переменной-счетчику и прибавьте нулевой по индексу элемент значения (кортежа) ко второй переменной-счетчику.\nПроверьте, что первая переменная-счетчик не равна нулю, и если да, то пусть функция вернет список из двух значений: логической константы True и значения второй-переменной счетчика; иначе пусть функция вернет логическую константу False.", "correct_example": "def text_check(data):\n    counter = 0\n    summa = 0\n    for k, v in data.items():\n        if v[1] == 'переведена':\n            counter += 1\n            summa += v[0]\n\n    if counter != 0:\n        return ([True, summa])\n\n    return False", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n{    'Героический эпос народов СССР. № 1': (100000, 'переведена'),    'Героический эпос народов СССР. № 2': (1005, 'не переведена')}\nОжидаемый ответ:\n[True, 100000]\nОтвет решения:\n(True, 100000)\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "553": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nopen('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "554": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "555": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "556": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "557": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n                \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "558": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "559": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for word in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "560": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "561": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[1].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "562": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line.strip()\n        \n        for p in punctuation:\n            line.replace(p, '')\n        \n        line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "563": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].upper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "564": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open(dialects.txt, 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "565": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "566": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "567": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "568": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data:\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "569": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v = 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "570": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if k == 2:\n        res.append(v)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "571": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "572": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*res)", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "573": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res)", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "574": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "575": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True))", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "576": {"student_solution": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=true), sep='; ')", "task": "Роман изучает свой отчет по итогам поездки в Англию, где он описывал различные диалекты. Помогите определить диалекты английского языка, которые упоминаются ровно 2 раза.\n\nФОРМАТ ВВОДА\nТекстовый файл dialects.txt, в котором записан отчет. Гарантируется, что в отчете только названия диалектов всегда записаны с большой буквы. При этом сами диалекты должны учитываться вне зависимости от регистра (например, \"Кардифф\" и \"КАРДиф\" должны считаться, как один диалект)\nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одного диалекта.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nНазвания диалектов, которые упоминаются в отчете ровно два раза. \nНазвания должны быть записаны в нижнем регистре в обратном алфавитном порядке через точку с запятой и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл dialects.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать диалекты и число их упоминаний.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке: если первая его буква — заглавная, тогда этот диалект и нужно проверить (не забудьте привести все буквы в диалекте к одному регистру):\nесли этого диалекта еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такой диалект уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить названия тех диалектов, значение которых в словаре ровно 2.\nОбратитесь к парам ключ-значение в словаре: если значение равно 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавиту порядке и напечатайте его элементы через точку с запятой и пробел.", "correct_example": "punctuation = '!#$%&()*+,-–./:;<=>?@^_'\n\ndata = {}\n\nwith open('dialects.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0].isupper():\n                if w.lower() not in data:\n                    data[w.lower()] = 1\n                else:\n                    data[w.lower()] += 1\n\n                 \nres = []\n\nfor k, v in data.items():\n    if v == 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "601": {"student_solution": "winners = []\n\n# ваш код\n\nwhile True\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "task": "Реализуйте следующую программу:\n\nЗадан пустой список winners. Этот код уже написан.\nВ цикле while считываются строки до тех пор, пока не введена строка \"СТОП\".\nДля каждой вводимой строки сделайте проверку — если она не начинается со строки \"3 место\" и в ней есть слово \"айдентика\", добавьте ее в список winners.\nГарантируется, что до слова \"СТОП\" будет введена как минимум одна строка.\nНапечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.", "correct_example": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\17\\codefile.py\", line 6\n    while True\n              ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "602": {"student_solution": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'END':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "task": "Реализуйте следующую программу:\n\nЗадан пустой список winners. Этот код уже написан.\nВ цикле while считываются строки до тех пор, пока не введена строка \"СТОП\".\nДля каждой вводимой строки сделайте проверку — если она не начинается со строки \"3 место\" и в ней есть слово \"айдентика\", добавьте ее в список winners.\nГарантируется, что до слова \"СТОП\" будет введена как минимум одна строка.\nНапечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.", "correct_example": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\17\\codefile.py\", line 7, in <module>\n    info = input()\nEOFError: EOF when reading a line\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "603": {"student_solution": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info = 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "task": "Реализуйте следующую программу:\n\nЗадан пустой список winners. Этот код уже написан.\nВ цикле while считываются строки до тех пор, пока не введена строка \"СТОП\".\nДля каждой вводимой строки сделайте проверку — если она не начинается со строки \"3 место\" и в ней есть слово \"айдентика\", добавьте ее в список winners.\nГарантируется, что до слова \"СТОП\" будет введена как минимум одна строка.\nНапечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.", "correct_example": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\17\\codefile.py\", line 9\n    if info = 'СТОП':\n            ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "604": {"student_solution": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if айдентика in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "task": "Реализуйте следующую программу:\n\nЗадан пустой список winners. Этот код уже написан.\nВ цикле while считываются строки до тех пор, пока не введена строка \"СТОП\".\nДля каждой вводимой строки сделайте проверку — если она не начинается со строки \"3 место\" и в ней есть слово \"айдентика\", добавьте ее в список winners.\nГарантируется, что до слова \"СТОП\" будет введена как минимум одна строка.\nНапечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.", "correct_example": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\17\\codefile.py\", line 12, in <module>\n    if айдентика in info and not(info.startswith('3 место')):\nNameError: name 'айдентика' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "605": {"student_solution": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info or not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "task": "Реализуйте следующую программу:\n\nЗадан пустой список winners. Этот код уже написан.\nВ цикле while считываются строки до тех пор, пока не введена строка \"СТОП\".\nДля каждой вводимой строки сделайте проверку — если она не начинается со строки \"3 место\" и в ней есть слово \"айдентика\", добавьте ее в список winners.\nГарантируется, что до слова \"СТОП\" будет введена как минимум одна строка.\nНапечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.", "correct_example": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП\nОжидаемый ответ:\n['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']\nОтвет решения:\n['2 место – Nightmares (саунд)', '1 место – Антиборщевик (айдентика)', '1 место – Исследователи (иллюстрация и комикс)', '2 место – Ripped Beauty (айдентика)', '1 место – Tropic Mayhem (игровая графика)']\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "606": {"student_solution": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info: \n        winners.append(info)\n    if not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "task": "Реализуйте следующую программу:\n\nЗадан пустой список winners. Этот код уже написан.\nВ цикле while считываются строки до тех пор, пока не введена строка \"СТОП\".\nДля каждой вводимой строки сделайте проверку — если она не начинается со строки \"3 место\" и в ней есть слово \"айдентика\", добавьте ее в список winners.\nГарантируется, что до слова \"СТОП\" будет введена как минимум одна строка.\nНапечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.", "correct_example": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП\nОжидаемый ответ:\n['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']\nОтвет решения:\n['2 место – Nightmares (саунд)', '1 место – Антиборщевик (айдентика)', '1 место – Антиборщевик (айдентика)', '1 место – Исследователи (иллюстрация и комикс)', '2 место – Ripped Beauty (айдентика)', '2 место – Ripped Beauty (айдентика)', '1 место – Tropic Mayhem (игровая графика)']\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "607": {"student_solution": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' not in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "task": "Реализуйте следующую программу:\n\nЗадан пустой список winners. Этот код уже написан.\nВ цикле while считываются строки до тех пор, пока не введена строка \"СТОП\".\nДля каждой вводимой строки сделайте проверку — если она не начинается со строки \"3 место\" и в ней есть слово \"айдентика\", добавьте ее в список winners.\nГарантируется, что до слова \"СТОП\" будет введена как минимум одна строка.\nНапечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.", "correct_example": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП\nОжидаемый ответ:\n['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']\nОтвет решения:\n['2 место – Nightmares (саунд)', '1 место – Исследователи (иллюстрация и комикс)', '1 место – Tropic Mayhem (игровая графика)']\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "608": {"student_solution": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and info.startswith('3 место'):\n        winners.append(info)\nprint(winners)", "task": "Реализуйте следующую программу:\n\nЗадан пустой список winners. Этот код уже написан.\nВ цикле while считываются строки до тех пор, пока не введена строка \"СТОП\".\nДля каждой вводимой строки сделайте проверку — если она не начинается со строки \"3 место\" и в ней есть слово \"айдентика\", добавьте ее в список winners.\nГарантируется, что до слова \"СТОП\" будет введена как минимум одна строка.\nНапечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.", "correct_example": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП\nОжидаемый ответ:\n['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']\nОтвет решения:\n[]\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "609": {"student_solution": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('1 место')):\n        winners.append(info)\nprint(winners)", "task": "Реализуйте следующую программу:\n\nЗадан пустой список winners. Этот код уже написан.\nВ цикле while считываются строки до тех пор, пока не введена строка \"СТОП\".\nДля каждой вводимой строки сделайте проверку — если она не начинается со строки \"3 место\" и в ней есть слово \"айдентика\", добавьте ее в список winners.\nГарантируется, что до слова \"СТОП\" будет введена как минимум одна строка.\nНапечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.", "correct_example": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП\nОжидаемый ответ:\n['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']\nОтвет решения:\n['2 место – Ripped Beauty (айдентика)']\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "610": {"student_solution": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'саунд' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "task": "Реализуйте следующую программу:\n\nЗадан пустой список winners. Этот код уже написан.\nВ цикле while считываются строки до тех пор, пока не введена строка \"СТОП\".\nДля каждой вводимой строки сделайте проверку — если она не начинается со строки \"3 место\" и в ней есть слово \"айдентика\", добавьте ее в список winners.\nГарантируется, что до слова \"СТОП\" будет введена как минимум одна строка.\nНапечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.", "correct_example": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП\nОжидаемый ответ:\n['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']\nОтвет решения:\n['2 место – Nightmares (саунд)']\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "611": {"student_solution": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.endswith('3 место')):\n        winners.append(info)\nprint(winners)", "task": "Реализуйте следующую программу:\n\nЗадан пустой список winners. Этот код уже написан.\nВ цикле while считываются строки до тех пор, пока не введена строка \"СТОП\".\nДля каждой вводимой строки сделайте проверку — если она не начинается со строки \"3 место\" и в ней есть слово \"айдентика\", добавьте ее в список winners.\nГарантируется, что до слова \"СТОП\" будет введена как минимум одна строка.\nНапечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.", "correct_example": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n2 место – Fireworks Massacre (игровая графика)\n2 место – Tress//passing (айдентика)\n1 место – Стеллаж TWIST (предметный дизайн)\n2 место – Minerals (саунд)\n3 место – Dark F (айдентика)\nСТОП\nОжидаемый ответ:\n['2 место – Tress//passing (айдентика)']\nОтвет решения:\n['2 место – Tress//passing (айдентика)', '3 место – Dark F (айдентика)']\n\n", "error_on_open": false, "error_on_closed": true, "syntax_error": false}, "612": {"student_solution": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.add(info)\nprint(winners)", "task": "Реализуйте следующую программу:\n\nЗадан пустой список winners. Этот код уже написан.\nВ цикле while считываются строки до тех пор, пока не введена строка \"СТОП\".\nДля каждой вводимой строки сделайте проверку — если она не начинается со строки \"3 место\" и в ней есть слово \"айдентика\", добавьте ее в список winners.\nГарантируется, что до слова \"СТОП\" будет введена как минимум одна строка.\nНапечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.", "correct_example": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\17\\codefile.py\", line 13, in <module>\n    winners.add(info)\nAttributeError: 'list' object has no attribute 'add'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "613": {"student_solution": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\n    print(winners)", "task": "Реализуйте следующую программу:\n\nЗадан пустой список winners. Этот код уже написан.\nВ цикле while считываются строки до тех пор, пока не введена строка \"СТОП\".\nДля каждой вводимой строки сделайте проверку — если она не начинается со строки \"3 место\" и в ней есть слово \"айдентика\", добавьте ее в список winners.\nГарантируется, что до слова \"СТОП\" будет введена как минимум одна строка.\nНапечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.", "correct_example": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП\nОжидаемый ответ:\n['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']\nОтвет решения:\n[]\n['1 место – Антиборщевик (айдентика)']\n['1 место – Антиборщевик (айдентика)']\n['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']\n['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "614": {"student_solution": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winers.append(info)\nprint(winners)", "task": "Реализуйте следующую программу:\n\nЗадан пустой список winners. Этот код уже написан.\nВ цикле while считываются строки до тех пор, пока не введена строка \"СТОП\".\nДля каждой вводимой строки сделайте проверку — если она не начинается со строки \"3 место\" и в ней есть слово \"айдентика\", добавьте ее в список winners.\nГарантируется, что до слова \"СТОП\" будет введена как минимум одна строка.\nНапечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.", "correct_example": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\n2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\17\\codefile.py\", line 13, in <module>\n    winers.append(info)\nNameError: name 'winers' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "615": {"student_solution": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(*winners)", "task": "Реализуйте следующую программу:\n\nЗадан пустой список winners. Этот код уже написан.\nВ цикле while считываются строки до тех пор, пока не введена строка \"СТОП\".\nДля каждой вводимой строки сделайте проверку — если она не начинается со строки \"3 место\" и в ней есть слово \"айдентика\", добавьте ее в список winners.\nГарантируется, что до слова \"СТОП\" будет введена как минимум одна строка.\nНапечатайте список winners. Строки в нем должны идти в том же порядке, что и при вводе.", "correct_example": "winners = []\n\n# ваш код\n\nwhile True:\n    info = input()\n    \n    if info == 'СТОП':\n        break\n    \n    if 'айдентика' in info and not(info.startswith('3 место')):\n        winners.append(info)\nprint(winners)", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\n2 место – Nightmares (саунд)\n1 место – Антиборщевик (айдентика)\n1 место – Исследователи (иллюстрация и комикс)\n2 место – Ripped Beauty (айдентика)\n1 место – Tropic Mayhem (игровая графика)\nСТОП\nОжидаемый ответ:\n['1 место – Антиборщевик (айдентика)', '2 место – Ripped Beauty (айдентика)']\nОтвет решения:\n1 место – Антиборщевик (айдентика) 2 место – Ripped Beauty (айдентика)\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "616": {"student_solution": "agencies = input().split()\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n        us.append(agency)\n        \nprint(sorted(us))", "task": "Реализуйте следующую программу:\n\nВ переменную agencies считывается список названий агентств. Этот код уже написан.\nПрограмма проверяет, какие названия агентств оканчиваются на \"ум\". Если такие строки есть, то программа сохраняет их в отдельный список.\nВ конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.\nЕсли таких строк нет, программа печатает пустой список.", "correct_example": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n        us.append(agency)\n        \nprint(sorted(us))", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nШедеврум Авалонун Концептиус Кордицепсум Умникус\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\18\\codefile.py\", line 6, in <module>\n    us.append(agency)\nNameError: name 'us' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "617": {"student_solution": "agencies = input().split()\nus = []\n\nfor i in agencies:\n    if agency.endswith('ум'):\n        us.append(agency)\n        \nprint(sorted(us))", "task": "Реализуйте следующую программу:\n\nВ переменную agencies считывается список названий агентств. Этот код уже написан.\nПрограмма проверяет, какие названия агентств оканчиваются на \"ум\". Если такие строки есть, то программа сохраняет их в отдельный список.\nВ конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.\nЕсли таких строк нет, программа печатает пустой список.", "correct_example": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n        us.append(agency)\n        \nprint(sorted(us))", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nШедеврум Авалонун Концептиус Кордицепсум Умникус\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\18\\codefile.py\", line 6, in <module>\n    if agency.endswith('ум'):\nNameError: name 'agency' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "618": {"student_solution": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency[-2] ==  'ум':\n        us.append(agency)\n        \nprint(sorted(us))", "task": "Реализуйте следующую программу:\n\nВ переменную agencies считывается список названий агентств. Этот код уже написан.\nПрограмма проверяет, какие названия агентств оканчиваются на \"ум\". Если такие строки есть, то программа сохраняет их в отдельный список.\nВ конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.\nЕсли таких строк нет, программа печатает пустой список.", "correct_example": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n        us.append(agency)\n        \nprint(sorted(us))", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nШедеврум Авалонун Концептиус Кордицепсум Умникус\nОжидаемый ответ:\n['Кордицепсум', 'Шедеврум']\nОтвет решения:\n[]\n\n", "error_on_open": true, "error_on_closed": false, "syntax_error": false}, "619": {"student_solution": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith(ум):\n        us.append(agency)\n        \nprint(sorted(us))", "task": "Реализуйте следующую программу:\n\nВ переменную agencies считывается список названий агентств. Этот код уже написан.\nПрограмма проверяет, какие названия агентств оканчиваются на \"ум\". Если такие строки есть, то программа сохраняет их в отдельный список.\nВ конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.\nЕсли таких строк нет, программа печатает пустой список.", "correct_example": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n        us.append(agency)\n        \nprint(sorted(us))", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nШедеврум Авалонун Концептиус Кордицепсум Умникус\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\18\\codefile.py\", line 6, in <module>\n    if agency.endswith(ум):\nNameError: name 'ум' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "620": {"student_solution": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n        us.append(agencies)\n        \nprint(sorted(us))", "task": "Реализуйте следующую программу:\n\nВ переменную agencies считывается список названий агентств. Этот код уже написан.\nПрограмма проверяет, какие названия агентств оканчиваются на \"ум\". Если такие строки есть, то программа сохраняет их в отдельный список.\nВ конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.\nЕсли таких строк нет, программа печатает пустой список.", "correct_example": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n        us.append(agency)\n        \nprint(sorted(us))", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nШедеврум Авалонун Концептиус Кордицепсум Умникус\nОжидаемый ответ:\n['Кордицепсум', 'Шедеврум']\nОтвет решения:\n[['Шедеврум', 'Авалонун', 'Концептиус', 'Кордицепсум', 'Умникус'], ['Шедеврум', 'Авалонун', 'Концептиус', 'Кордицепсум', 'Умникус']]\n\n", "error_on_open": true, "error_on_closed": false, "syntax_error": false}, "621": {"student_solution": "agencies = input().split()\nus = []\n\nfor agency in agencies\n    if agency.endswith('ум'):\n        us.append(agency)\n        \nprint(sorted(us))", "task": "Реализуйте следующую программу:\n\nВ переменную agencies считывается список названий агентств. Этот код уже написан.\nПрограмма проверяет, какие названия агентств оканчиваются на \"ум\". Если такие строки есть, то программа сохраняет их в отдельный список.\nВ конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.\nЕсли таких строк нет, программа печатает пустой список.", "correct_example": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n        us.append(agency)\n        \nprint(sorted(us))", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nШедеврум Авалонун Концептиус Кордицепсум Умникус\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\18\\codefile.py\", line 5\n    for agency in agencies\n                          ^\nSyntaxError: invalid syntax\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "622": {"student_solution": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n    us.append(agency)\n        \nprint(sorted(us))", "task": "Реализуйте следующую программу:\n\nВ переменную agencies считывается список названий агентств. Этот код уже написан.\nПрограмма проверяет, какие названия агентств оканчиваются на \"ум\". Если такие строки есть, то программа сохраняет их в отдельный список.\nВ конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.\nЕсли таких строк нет, программа печатает пустой список.", "correct_example": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n        us.append(agency)\n        \nprint(sorted(us))", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nШедеврум Авалонун Концептиус Кордицепсум Умникус\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\18\\codefile.py\", line 7\n    us.append(agency)\n    ^\nIndentationError: expected an indented block\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "623": {"student_solution": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n        us.append(agency)\n        \nprint(us)", "task": "Реализуйте следующую программу:\n\nВ переменную agencies считывается список названий агентств. Этот код уже написан.\nПрограмма проверяет, какие названия агентств оканчиваются на \"ум\". Если такие строки есть, то программа сохраняет их в отдельный список.\nВ конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.\nЕсли таких строк нет, программа печатает пустой список.", "correct_example": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n        us.append(agency)\n        \nprint(sorted(us))", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nШедеврум Авалонун Концептиус Кордицепсум Умникус\nОжидаемый ответ:\n['Кордицепсум', 'Шедеврум']\nОтвет решения:\n['Шедеврум', 'Кордицепсум']\n\n", "error_on_open": true, "error_on_closed": false, "syntax_error": false}, "624": {"student_solution": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n        us.append(agency)\n        \nprint(sorted(us, reverse = True))", "task": "Реализуйте следующую программу:\n\nВ переменную agencies считывается список названий агентств. Этот код уже написан.\nПрограмма проверяет, какие названия агентств оканчиваются на \"ум\". Если такие строки есть, то программа сохраняет их в отдельный список.\nВ конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.\nЕсли таких строк нет, программа печатает пустой список.", "correct_example": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n        us.append(agency)\n        \nprint(sorted(us))", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nШедеврум Авалонун Концептиус Кордицепсум Умникус\nОжидаемый ответ:\n['Кордицепсум', 'Шедеврум']\nОтвет решения:\n['Шедеврум', 'Кордицепсум']\n\n", "error_on_open": true, "error_on_closed": false, "syntax_error": false}, "625": {"student_solution": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n        us.append(agency)\n        \nprint(*sorted(us))", "task": "Реализуйте следующую программу:\n\nВ переменную agencies считывается список названий агентств. Этот код уже написан.\nПрограмма проверяет, какие названия агентств оканчиваются на \"ум\". Если такие строки есть, то программа сохраняет их в отдельный список.\nВ конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.\nЕсли таких строк нет, программа печатает пустой список.", "correct_example": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n        us.append(agency)\n        \nprint(sorted(us))", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nШедеврум Авалонун Концептиус Кордицепсум Умникус\nОжидаемый ответ:\n['Кордицепсум', 'Шедеврум']\nОтвет решения:\nКордицепсум Шедеврум\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "626": {"student_solution": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n        us.append(agency)\n        \nprint(*us)", "task": "Реализуйте следующую программу:\n\nВ переменную agencies считывается список названий агентств. Этот код уже написан.\nПрограмма проверяет, какие названия агентств оканчиваются на \"ум\". Если такие строки есть, то программа сохраняет их в отдельный список.\nВ конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.\nЕсли таких строк нет, программа печатает пустой список.", "correct_example": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n        us.append(agency)\n        \nprint(sorted(us))", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nШедеврум Авалонун Концептиус Кордицепсум Умникус\nОжидаемый ответ:\n['Кордицепсум', 'Шедеврум']\nОтвет решения:\nШедеврум Кордицепсум\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "627": {"student_solution": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n        us.append(agency)\n        \n    print(sorted(us))", "task": "Реализуйте следующую программу:\n\nВ переменную agencies считывается список названий агентств. Этот код уже написан.\nПрограмма проверяет, какие названия агентств оканчиваются на \"ум\". Если такие строки есть, то программа сохраняет их в отдельный список.\nВ конце программа печатает отсортированный в алфавитном порядке список с названиями агентств, которые были туда сохранены.\nЕсли таких строк нет, программа печатает пустой список.", "correct_example": "agencies = input().split()\nus = []\n\nfor agency in agencies:\n    if agency.endswith('ум'):\n        us.append(agency)\n        \nprint(sorted(us))", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nШедеврум Авалонун Концептиус Кордицепсум Умникус\nОжидаемый ответ:\n['Кордицепсум', 'Шедеврум']\nОтвет решения:\n['Шедеврум']\n['Шедеврум']\n['Шедеврум']\n['Кордицепсум', 'Шедеврум']\n['Кордицепсум', 'Шедеврум']\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "628": {"student_solution": "anna_choice = input().split()\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((anna_choice & galina_choice).intersection(top10))))", "task": "Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:\n\nВ переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.\nВ переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.\nВ переменную top10 считывается список строк (названия агенств, входящих в топ-10).\nГарантируется, что для каждого списка будет введено хотя бы одно значение.\nПрограмма выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.\nНазвания должны быть отсортированы в алфавитном порядке.\nЕсли таких агенств нет, программа ничего не выводит. ", "correct_example": "anna_choice = input().split()\n\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\19\\codefile.py\", line 6, in <module>\n    print(', '.join(sorted((anna_choice & galina_choice).intersection(top10))))\nTypeError: unsupported operand type(s) for &: 'list' and 'list'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "629": {"student_solution": "anna_choice = input().split()\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((set(anna_choice) - set(galina_choice)).intersection(set(top10)))))", "task": "Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:\n\nВ переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.\nВ переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.\nВ переменную top10 считывается список строк (названия агенств, входящих в топ-10).\nГарантируется, что для каждого списка будет введено хотя бы одно значение.\nПрограмма выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.\nНазвания должны быть отсортированы в алфавитном порядке.\nЕсли таких агенств нет, программа ничего не выводит. ", "correct_example": "anna_choice = input().split()\n\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус\nОжидаемый ответ:\nДинамитус, Симфониус, Шедеврум\nОтвет решения:\n\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "630": {"student_solution": "anna_choice = input().split()\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted(set(anna_choice) & set(galina_choice) & (set(top10))))", "task": "Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:\n\nВ переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.\nВ переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.\nВ переменную top10 считывается список строк (названия агенств, входящих в топ-10).\nГарантируется, что для каждого списка будет введено хотя бы одно значение.\nПрограмма выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.\nНазвания должны быть отсортированы в алфавитном порядке.\nЕсли таких агенств нет, программа ничего не выводит. ", "correct_example": "anna_choice = input().split()\n\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус\nЛог:\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\19\\codefile.py\", line 7\n    \n    ^\nSyntaxError: unexpected EOF while parsing\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": true}, "631": {"student_solution": "anna_choice = input().split()\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((set(anna_choice) + set(galina_choice)).intersection(set(top10)))))", "task": "Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:\n\nВ переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.\nВ переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.\nВ переменную top10 считывается список строк (названия агенств, входящих в топ-10).\nГарантируется, что для каждого списка будет введено хотя бы одно значение.\nПрограмма выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.\nНазвания должны быть отсортированы в алфавитном порядке.\nЕсли таких агенств нет, программа ничего не выводит. ", "correct_example": "anna_choice = input().split()\n\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\19\\codefile.py\", line 6, in <module>\n    print(', '.join(sorted((set(anna_choice) + set(galina_choice)).intersection(set(top10)))))\nTypeError: unsupported operand type(s) for +: 'set' and 'set'\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "632": {"student_solution": "anna_choice = input().split()\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((set(anna_choice) & set(galina_choice)) - set(top10))))", "task": "Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:\n\nВ переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.\nВ переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.\nВ переменную top10 считывается список строк (названия агенств, входящих в топ-10).\nГарантируется, что для каждого списка будет введено хотя бы одно значение.\nПрограмма выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.\nНазвания должны быть отсортированы в алфавитном порядке.\nЕсли таких агенств нет, программа ничего не выводит. ", "correct_example": "anna_choice = input().split()\n\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус\nОжидаемый ответ:\nДинамитус, Симфониус, Шедеврум\nОтвет решения:\n\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "633": {"student_solution": "anna_choice = input().split()\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((set(annachoice) & set(galinachoice)).intersection(set(top10)))))", "task": "Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:\n\nВ переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.\nВ переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.\nВ переменную top10 считывается список строк (названия агенств, входящих в топ-10).\nГарантируется, что для каждого списка будет введено хотя бы одно значение.\nПрограмма выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.\nНазвания должны быть отсортированы в алфавитном порядке.\nЕсли таких агенств нет, программа ничего не выводит. ", "correct_example": "anna_choice = input().split()\n\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))", "tester_report": "На одном из тестов решение выполнилось с ошибкой.\nВвод теста:\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус\nЛог:\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Desktop\\hack\\HSE AI Assistant hack\\pocket-tutor-py\\cache\\19\\codefile.py\", line 6, in <module>\n    print(', '.join(sorted((set(annachoice) & set(galinachoice)).intersection(set(top10)))))\nNameError: name 'annachoice' is not defined\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "634": {"student_solution": "anna_choice = input().split()\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((set(anna_choice) and set(galina_choice)).intersection(set(top10)))))", "task": "Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:\n\nВ переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.\nВ переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.\nВ переменную top10 считывается список строк (названия агенств, входящих в топ-10).\nГарантируется, что для каждого списка будет введено хотя бы одно значение.\nПрограмма выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.\nНазвания должны быть отсортированы в алфавитном порядке.\nЕсли таких агенств нет, программа ничего не выводит. ", "correct_example": "anna_choice = input().split()\n\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nИнспиратус Экспрессивус Прогрессус Эксклюзивус\nЭксклюзивус Экспрессивус Авангардус\nАвангардус Инспиратус Эстетус Экспрессивус\nОжидаемый ответ:\nЭкспрессивус\nОтвет решения:\nАвангардус, Экспрессивус\n\n", "error_on_open": true, "error_on_closed": false, "syntax_error": false}, "635": {"student_solution": "anna_choice = input().split()\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join((set(anna_choice) & set(galina_choice)).intersection(set(top10))))", "task": "Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:\n\nВ переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.\nВ переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.\nВ переменную top10 считывается список строк (названия агенств, входящих в топ-10).\nГарантируется, что для каждого списка будет введено хотя бы одно значение.\nПрограмма выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.\nНазвания должны быть отсортированы в алфавитном порядке.\nЕсли таких агенств нет, программа ничего не выводит. ", "correct_example": "anna_choice = input().split()\n\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус\nОжидаемый ответ:\nДинамитус, Симфониус, Шедеврум\nОтвет решения:\nСимфониус, Динамитус, Шедеврум\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "636": {"student_solution": "anna_choice = input().split()\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint('; '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))", "task": "Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:\n\nВ переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.\nВ переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.\nВ переменную top10 считывается список строк (названия агенств, входящих в топ-10).\nГарантируется, что для каждого списка будет введено хотя бы одно значение.\nПрограмма выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.\nНазвания должны быть отсортированы в алфавитном порядке.\nЕсли таких агенств нет, программа ничего не выводит. ", "correct_example": "anna_choice = input().split()\n\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус\nОжидаемый ответ:\nДинамитус, Симфониус, Шедеврум\nОтвет решения:\nДинамитус; Симфониус; Шедеврум\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "637": {"student_solution": "anna_choice = input().split()\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)), reverse = True)))", "task": "Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:\n\nВ переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.\nВ переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.\nВ переменную top10 считывается список строк (названия агенств, входящих в топ-10).\nГарантируется, что для каждого списка будет введено хотя бы одно значение.\nПрограмма выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.\nНазвания должны быть отсортированы в алфавитном порядке.\nЕсли таких агенств нет, программа ничего не выводит. ", "correct_example": "anna_choice = input().split()\n\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nШедеврум Про-дизайнус Коммуникатус Симфониус Динамитус\nСимфониус Динамитус Импрово Шедеврум\nДинамитус Шедеврум Симфониус\nОжидаемый ответ:\nДинамитус, Симфониус, Шедеврум\nОтвет решения:\nШедеврум, Симфониус, Динамитус\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "638": {"student_solution": "anna_choice = input().split()\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted(set(anna_choice) & set(galina_choice))))", "task": "Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:\n\nВ переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.\nВ переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.\nВ переменную top10 считывается список строк (названия агенств, входящих в топ-10).\nГарантируется, что для каждого списка будет введено хотя бы одно значение.\nПрограмма выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.\nНазвания должны быть отсортированы в алфавитном порядке.\nЕсли таких агенств нет, программа ничего не выводит. ", "correct_example": "anna_choice = input().split()\n\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nСимфониус Эмпатус Эксклюзивус\nЭксклюзивус Эволютус Симфониус\nШедеврум Эмпатус\nОжидаемый ответ:\n\nОтвет решения:\nСимфониус, Эксклюзивус\n\n", "error_on_open": true, "error_on_closed": false, "syntax_error": false}, "639": {"student_solution": "anna_choice = input().split()\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted(set(anna_choice) & set(top10))))", "task": "Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:\n\nВ переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.\nВ переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.\nВ переменную top10 считывается список строк (названия агенств, входящих в топ-10).\nГарантируется, что для каждого списка будет введено хотя бы одно значение.\nПрограмма выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.\nНазвания должны быть отсортированы в алфавитном порядке.\nЕсли таких агенств нет, программа ничего не выводит. ", "correct_example": "anna_choice = input().split()\n\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nСимфониус Эмпатус Эксклюзивус\nЭксклюзивус Эволютус Симфониус\nШедеврум Эмпатус\nОжидаемый ответ:\n\nОтвет решения:\nЭмпатус\n\n", "error_on_open": true, "error_on_closed": true, "syntax_error": false}, "640": {"student_solution": "anna_choice = input().split()\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted(set(galina_choice) & set(top10))))", "task": "Анна и Галина выбирают, в каком агентстве заказать айдентику для бренда одежды. Реализуйте программу, которая поможет им сделать выбор:\n\nВ переменную anna_choice считывается список строк (названия агенств, которым доверяет Анна). Этот код уже написан.\nВ переменную galina_choice считывается список строк (названия агенств, которым доверяет Галина). Этот код уже написан.\nВ переменную top10 считывается список строк (названия агенств, входящих в топ-10).\nГарантируется, что для каждого списка будет введено хотя бы одно значение.\nПрограмма выводит через запятую с пробелом названия агентств из топ-10, которым одновременно доверяют и Анна, и Галина.\nНазвания должны быть отсортированы в алфавитном порядке.\nЕсли таких агенств нет, программа ничего не выводит. ", "correct_example": "anna_choice = input().split()\n\ngalina_choice = input().split()\ntop10 = input().split()\n\nprint(', '.join(sorted((set(anna_choice) & set(galina_choice)).intersection(set(top10)))))", "tester_report": "На одном из тестов решение вернуло неверный ответ.\nВвод теста:\nИнспиратус Экспрессивус Прогрессус Эксклюзивус\nЭксклюзивус Экспрессивус Авангардус\nАвангардус Инспиратус Эстетус Экспрессивус\nОжидаемый ответ:\nЭкспрессивус\nОтвет решения:\nАвангардус, Экспрессивус\n\n", "error_on_open": true, "error_on_closed": false, "syntax_error": false}, "667": {"student_solution": "name = input()\n\nopen('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "task": "Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.\n\nПрограмма должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка \"Создание лендинга, Анастасия Иванова, 12000 р.\" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.\nГарантируется, что стоимость услуги всегда записана в формате \"<целое число> р.\".\nРазделителями данных в файле служат запятые с пробелом.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — имя дизайнера. Этот код уже написан.\nПрограмма должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "668": {"student_solution": "name = input()\n\nwith open('offers.txt', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "task": "Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.\n\nПрограмма должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка \"Создание лендинга, Анастасия Иванова, 12000 р.\" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.\nГарантируется, что стоимость услуги всегда записана в формате \"<целое число> р.\".\nРазделителями данных в файле служат запятые с пробелом.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — имя дизайнера. Этот код уже написан.\nПрограмма должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "669": {"student_solution": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as file:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "task": "Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.\n\nПрограмма должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка \"Создание лендинга, Анастасия Иванова, 12000 р.\" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.\nГарантируется, что стоимость услуги всегда записана в формате \"<целое число> р.\".\nРазделителями данных в файле служат запятые с пробелом.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — имя дизайнера. Этот код уже написан.\nПрограмма должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "670": {"student_solution": "name = input()\n\nwith open(offers.csv, encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "task": "Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.\n\nПрограмма должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка \"Создание лендинга, Анастасия Иванова, 12000 р.\" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.\nГарантируется, что стоимость услуги всегда записана в формате \"<целое число> р.\".\nРазделителями данных в файле служат запятые с пробелом.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — имя дизайнера. Этот код уже написан.\nПрограмма должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "671": {"student_solution": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.split(',')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "task": "Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.\n\nПрограмма должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка \"Создание лендинга, Анастасия Иванова, 12000 р.\" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.\nГарантируется, что стоимость услуги всегда записана в формате \"<целое число> р.\".\nРазделителями данных в файле служат запятые с пробелом.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — имя дизайнера. Этот код уже написан.\nПрограмма должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "672": {"student_solution": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] = name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "task": "Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.\n\nПрограмма должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка \"Создание лендинга, Анастасия Иванова, 12000 р.\" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.\nГарантируется, что стоимость услуги всегда записана в формате \"<целое число> р.\".\nРазделителями данных в файле служат запятые с пробелом.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — имя дизайнера. Этот код уже написан.\nПрограмма должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "673": {"student_solution": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name & int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "task": "Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.\n\nПрограмма должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка \"Создание лендинга, Анастасия Иванова, 12000 р.\" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.\nГарантируется, что стоимость услуги всегда записана в формате \"<целое число> р.\".\nРазделителями данных в файле служат запятые с пробелом.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — имя дизайнера. Этот код уже написан.\nПрограмма должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "674": {"student_solution": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] != name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "task": "Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.\n\nПрограмма должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка \"Создание лендинга, Анастасия Иванова, 12000 р.\" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.\nГарантируется, что стоимость услуги всегда записана в формате \"<целое число> р.\".\nРазделителями данных в файле служат запятые с пробелом.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — имя дизайнера. Этот код уже написан.\nПрограмма должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "675": {"student_solution": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name or int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "task": "Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.\n\nПрограмма должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка \"Создание лендинга, Анастасия Иванова, 12000 р.\" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.\nГарантируется, что стоимость услуги всегда записана в формате \"<целое число> р.\".\nРазделителями данных в файле служат запятые с пробелом.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — имя дизайнера. Этот код уже написан.\nПрограмма должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "676": {"student_solution": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) < 5000:\n            print(line.strip())", "task": "Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.\n\nПрограмма должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка \"Создание лендинга, Анастасия Иванова, 12000 р.\" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.\nГарантируется, что стоимость услуги всегда записана в формате \"<целое число> р.\".\nРазделителями данных в файле служат запятые с пробелом.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — имя дизайнера. Этот код уже написан.\nПрограмма должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "677": {"student_solution": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and info[-1].split()[0] <= 5000:\n            print(line.strip())", "task": "Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.\n\nПрограмма должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка \"Создание лендинга, Анастасия Иванова, 12000 р.\" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.\nГарантируется, что стоимость услуги всегда записана в формате \"<целое число> р.\".\nРазделителями данных в файле служат запятые с пробелом.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — имя дизайнера. Этот код уже написан.\nПрограмма должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "678": {"student_solution": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[2] == name and int(info[3].split()[0]) <= 5000:\n            print(line.strip())", "task": "Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.\n\nПрограмма должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка \"Создание лендинга, Анастасия Иванова, 12000 р.\" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.\nГарантируется, что стоимость услуги всегда записана в формате \"<целое число> р.\".\nРазделителями данных в файле служат запятые с пробелом.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — имя дизайнера. Этот код уже написан.\nПрограмма должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "679": {"student_solution": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1]) <= 5000:\n            print(line.strip())", "task": "Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.\n\nПрограмма должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка \"Создание лендинга, Анастасия Иванова, 12000 р.\" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.\nГарантируется, что стоимость услуги всегда записана в формате \"<целое число> р.\".\nРазделителями данных в файле служат запятые с пробелом.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — имя дизайнера. Этот код уже написан.\nПрограмма должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "680": {"student_solution": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line)", "task": "Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.\n\nПрограмма должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка \"Создание лендинга, Анастасия Иванова, 12000 р.\" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.\nГарантируется, что стоимость услуги всегда записана в формате \"<целое число> р.\".\nРазделителями данных в файле служат запятые с пробелом.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — имя дизайнера. Этот код уже написан.\nПрограмма должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "681": {"student_solution": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n        print(line.strip())", "task": "Галина анализирует стоимость услуг дизайнеров для ее сайта, которые собраны в файле формата csv. Напишите программу, которая выводит все строки с услугами интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей.\n\nПрограмма должна открывать структурированный текстовый файл offers.csv, в кодировке utf-8, где на каждой строке записана следующая информация об услугах: название услуги, имя дизайнера, стоимость услуги. Например, строка \"Создание лендинга, Анастасия Иванова, 12000 р.\" означает, что за создание лендинга дизайнер Анастасия Иванова запрашивает 12000 рублей.\nГарантируется, что стоимость услуги всегда записана в формате \"<целое число> р.\".\nРазделителями данных в файле служат запятые с пробелом.\nГарантируется, что в файле есть как минимум одна строка с данными. \nС клавиатуры вводится строка — имя дизайнера. Этот код уже написан.\nПрограмма должна выводить строки из оригинального файла, в которых есть только услуги интересующего дизайнера, а стоимость каждой услуги не превышает 5000 рублей (не забудьте удалить символы конца строки!).\nЕсли подходящих под условие строк в файле нет, то программа ничего не выводит.\nДОПОЛНИТЕЛЬНО\nВаше решение будет проверяться на закрытых тестах. Ваш код должен считывать файл offers.csv без дополнительных указаний (например, пути к файлу на вашем компьютере).\nВ открытом тесте используется файл offers.csv. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.", "correct_example": "name = input()\n\nwith open('offers.csv', encoding='utf-8') as infile:\n    for line in infile:\n        info = line.strip().split(', ')\n        if info[1] == name and int(info[-1].split()[0]) <= 5000:\n            print(line.strip())", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "730": {"student_solution": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nopen('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "task": "Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». \n\nФОРМАТ ВВОДА\nТекстовый файл designtalks.txt, в котором записан текст из журнала. \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одной студии.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nСтудии дизайна, встретившиеся в тексте более двух раз.\nСтудии должны быть записаны в обратном алфавитном порядке через запятую и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать слова и их количество.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:\nесли этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.\nОбратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.", "correct_example": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "731": {"student_solution": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.csv', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "task": "Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». \n\nФОРМАТ ВВОДА\nТекстовый файл designtalks.txt, в котором записан текст из журнала. \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одной студии.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nСтудии дизайна, встретившиеся в тексте более двух раз.\nСтудии должны быть записаны в обратном алфавитном порядке через запятую и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать слова и их количество.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:\nесли этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.\nОбратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.", "correct_example": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "732": {"student_solution": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "task": "Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». \n\nФОРМАТ ВВОДА\nТекстовый файл designtalks.txt, в котором записан текст из журнала. \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одной студии.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nСтудии дизайна, встретившиеся в тексте более двух раз.\nСтудии должны быть записаны в обратном алфавитном порядке через запятую и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать слова и их количество.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:\nесли этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.\nОбратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.", "correct_example": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "733": {"student_solution": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as myfile:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "task": "Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». \n\nФОРМАТ ВВОДА\nТекстовый файл designtalks.txt, в котором записан текст из журнала. \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одной студии.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nСтудии дизайна, встретившиеся в тексте более двух раз.\nСтудии должны быть записаны в обратном алфавитном порядке через запятую и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать слова и их количество.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:\nесли этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.\nОбратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.", "correct_example": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "734": {"student_solution": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "task": "Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». \n\nФОРМАТ ВВОДА\nТекстовый файл designtalks.txt, в котором записан текст из журнала. \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одной студии.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nСтудии дизайна, встретившиеся в тексте более двух раз.\nСтудии должны быть записаны в обратном алфавитном порядке через запятую и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать слова и их количество.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:\nесли этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.\nОбратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.", "correct_example": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "735": {"student_solution": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line.strip()\n        \n        for p in punctuation:\n           line.replace(p, '')\n        \n        line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "task": "Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». \n\nФОРМАТ ВВОДА\nТекстовый файл designtalks.txt, в котором записан текст из журнала. \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одной студии.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nСтудии дизайна, встретившиеся в тексте более двух раз.\nСтудии должны быть записаны в обратном алфавитном порядке через запятую и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать слова и их количество.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:\nесли этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.\nОбратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.", "correct_example": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "736": {"student_solution": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] = '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "task": "Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». \n\nФОРМАТ ВВОДА\nТекстовый файл designtalks.txt, в котором записан текст из журнала. \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одной студии.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nСтудии дизайна, встретившиеся в тексте более двух раз.\nСтудии должны быть записаны в обратном алфавитном порядке через запятую и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать слова и их количество.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:\nесли этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.\nОбратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.", "correct_example": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "737": {"student_solution": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == \"«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "task": "Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». \n\nФОРМАТ ВВОДА\nТекстовый файл designtalks.txt, в котором записан текст из журнала. \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одной студии.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nСтудии дизайна, встретившиеся в тексте более двух раз.\nСтудии должны быть записаны в обратном алфавитном порядке через запятую и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать слова и их количество.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:\nесли этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.\nОбратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.", "correct_example": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "738": {"student_solution": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "task": "Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». \n\nФОРМАТ ВВОДА\nТекстовый файл designtalks.txt, в котором записан текст из журнала. \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одной студии.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nСтудии дизайна, встретившиеся в тексте более двух раз.\nСтудии должны быть записаны в обратном алфавитном порядке через запятую и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать слова и их количество.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:\nесли этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.\nОбратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.", "correct_example": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "739": {"student_solution": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "task": "Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». \n\nФОРМАТ ВВОДА\nТекстовый файл designtalks.txt, в котором записан текст из журнала. \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одной студии.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nСтудии дизайна, встретившиеся в тексте более двух раз.\nСтудии должны быть записаны в обратном алфавитном порядке через запятую и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать слова и их количество.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:\nесли этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.\nОбратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.", "correct_example": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "740": {"student_solution": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data:\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "task": "Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». \n\nФОРМАТ ВВОДА\nТекстовый файл designtalks.txt, в котором записан текст из журнала. \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одной студии.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nСтудии дизайна, встретившиеся в тексте более двух раз.\nСтудии должны быть записаны в обратном алфавитном порядке через запятую и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать слова и их количество.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:\nесли этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.\nОбратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.", "correct_example": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "741": {"student_solution": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v >= 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "task": "Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». \n\nФОРМАТ ВВОДА\nТекстовый файл designtalks.txt, в котором записан текст из журнала. \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одной студии.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nСтудии дизайна, встретившиеся в тексте более двух раз.\nСтудии должны быть записаны в обратном алфавитном порядке через запятую и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать слова и их количество.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:\nесли этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.\nОбратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.", "correct_example": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "742": {"student_solution": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(v)\n        \nprint(*sorted(res))", "task": "Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». \n\nФОРМАТ ВВОДА\nТекстовый файл designtalks.txt, в котором записан текст из журнала. \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одной студии.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nСтудии дизайна, встретившиеся в тексте более двух раз.\nСтудии должны быть записаны в обратном алфавитном порядке через запятую и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать слова и их количество.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:\nесли этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.\nОбратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.", "correct_example": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "743": {"student_solution": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res), sep=', ')", "task": "Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». \n\nФОРМАТ ВВОДА\nТекстовый файл designtalks.txt, в котором записан текст из журнала. \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одной студии.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nСтудии дизайна, встретившиеся в тексте более двух раз.\nСтудии должны быть записаны в обратном алфавитном порядке через запятую и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать слова и их количество.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:\nесли этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.\nОбратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.", "correct_example": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "744": {"student_solution": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep='; ')", "task": "Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». \n\nФОРМАТ ВВОДА\nТекстовый файл designtalks.txt, в котором записан текст из журнала. \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одной студии.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nСтудии дизайна, встретившиеся в тексте более двух раз.\nСтудии должны быть записаны в обратном алфавитном порядке через запятую и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать слова и их количество.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:\nесли этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.\nОбратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.", "correct_example": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}, "745": {"student_solution": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \n    print(*sorted(res, reverse=True), sep=', ')", "task": "Лолита изучает, какие студии дизайна чаще всего дают комментарии в ее любимом журнале. Помогите определить студии, встретившиеся в тексте более двух раз. Гарантируется, что в тексте только названия сервисов написаны в кавычках «». \n\nФОРМАТ ВВОДА\nТекстовый файл designtalks.txt, в котором записан текст из журнала. \nГарантируется, что пустых строк в файле нет.\nГарантируется, что в файле будет упоминание хотя бы одной студии.\nТакже дана строка punctuation с символами, которые могут встречаться в тексте — необходимо будет очистить от них текст.\nФОРМАТ ВЫВОДА\nСтудии дизайна, встретившиеся в тексте более двух раз.\nСтудии должны быть записаны в обратном алфавитном порядке через запятую и пробел.\nДОПОЛНИТЕЛЬНО\nВ открытом тесте используется файл designtalks.txt. Вы можете скачать его и проверить свое решение локально.\nВ примере в первой колонке отображается номер теста (0 — открытый тест), считывать это число или использовать его в вашем решении не нужно.\nАЛГОРИТМ РЕШЕНИЯ \nЭто один из возможных алгоритмов решения задачи. Вы можете воспользоваться им в качестве подсказки или решить задачу любым другим удобным для вас способом.\nСоздайте пустой словарь, в который будете записывать слова и их количество.\nОткройте файл в режиме чтения в кодировке utf-8.\nОбратитесь к каждой строке в файле и выполните следующие действия:\nуберите невидимые символы в конце строки (символ перехода на новую строку);\nобратитесь к каждому символу в строке punctuation и используйте его для замены на пустую строку в строке файла;\nразбейте строку по разделителю, в результате получите список;\nобратитесь к каждому элементу в получившемся списке. Если первый символ — это кавычка «, тогда это студия дизайна, и нужно проверить:\nесли этого названия еще нет в словаре из п.1, то нужно его добавить в качестве ключа, присвоив значение 1.\nесли такое название уже есть в словаре из п.1, то нужно увеличить его значение на 1.\nПосле цикла создайте пустой список — в него нужно будет добавить те названия, значение которых в словаре более 2.\nОбратитесь к парам ключ-значение в словаре: если значение строго больше 2, то добавьте ключ в список из п.4.\nОтсортируйте список в обратном алфавитном порядке и напечатайте его элементы через запятую и пробел.", "correct_example": "punctuation = '!#$%&()*+,-./:;<=>?@^_'\n\ndata = {}\n\nwith open('designtalks.txt', 'r', encoding='utf-8') as my_file:\n    for line in my_file:\n        line = line.strip()\n        \n        for p in punctuation:\n            line = line.replace(p, '')\n        \n        line = line.split()\n        for w in line:\n            if w[0] == '«':\n                if w not in data:\n                    data[w] = 1\n                else:\n                    data[w] += 1\n                    \nres = []\n\nfor k, v in data.items():\n    if v > 2:\n        res.append(k)\n        \nprint(*sorted(res, reverse=True), sep=', ')", "tester_report": "Не удалось протестировать решение", "error_on_open": false, "error_on_closed": false, "syntax_error": false}}